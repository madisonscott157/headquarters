<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Headquarters</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #0d1421;
            min-height: 100vh;
            padding: 20px;
            position: relative;
            padding-bottom: 40px;
        }

        .container {
            max-width: 1350px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .horse-detail-view .container {
            max-width: 1550px;
            margin: 0 auto;
            padding: 0 10px;
        }
        
        /* Make gallops view wider */
        #gallopView .container {
            max-width: 1650px;
            margin: 0 auto;
            padding: 0 10px;
        }
        
        .horse-detail-view .table-container {
            overflow-x: auto;
            width: 100%;
            margin: 0;
            padding: 10px;
        }
        
        .horse-detail-view table {
            width: 100%;
            min-width: 1400px;
            table-layout: auto;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-weight: bold;
            color: #2c3e50;
            font-size: 0.9em;
        }

        select, input {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #3498db;
        }

        .file-input {
            margin-right: 20px;
        }

        #fileInput {
            display: none;
        }

        .file-label {
            background: #3498db;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .file-label:hover {
            background: #2980b9;
        }

        .export-btn {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(52, 73, 94, 0.2);
        }

        .export-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(52, 73, 94, 0.3);
        }

        .export-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .table-container {
            overflow-x: auto;
            padding: 20px;
            width: 100%;
            max-width: 100%;
        }
        
        /* Make ONLY main page table container wider */
        .table-container:has(#horseTable) {
            max-width: 2000px !important;
            margin: 0 auto !important;
            width: 100% !important;
        }
        

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border: 1px solid #e8eaed;
            table-layout: auto;
            font-size: 13px;
        }

        /* Larger font size for main page table */
        #horseTable {
            font-size: 14px !important;
        }
        
        /* Make sure all table content is larger */
        #horseTable th,
        #horseTable td,
        #horseTable .cell-content,
        #horseTable a {
            font-size: 14px !important;
        }

        th, td {
            padding: 10px 12px;
            text-align: center;
            border-bottom: 1px solid #e9ecef;
            position: relative;
            overflow: visible;
            white-space: nowrap;
        }
        
        .cell-content {
            position: relative;
            white-space: nowrap;
            overflow: visible;
            z-index: 10;
        }
        
        .horse-detail-view th, .horse-detail-view td {
            padding: 6px 4px;
            font-size: 12px;
            line-height: 1.2;
            vertical-align: top;
            position: relative;
            width: auto;
            max-width: 0;
            overflow: visible;
        }
        
        .horse-detail-view th {
            width: 80px !important;
            min-width: 80px;
            max-width: 80px;
            word-wrap: break-word;
        }
        
        .horse-detail-view .horse-name-cell {
            width: 1%;
            white-space: nowrap;
            text-align: left;
            padding-right: 8px;
        }
        
        .horse-name-cell {
            text-align: left;
            width: 160px;
        }
        
        .horse-name-link {
            text-decoration: none;
            cursor: pointer;
            font-weight: bold;
        }
        
        .horse-name-link:hover {
            text-decoration: underline;
        }
        
        .fast-recovery-col {
            width: 80px;
        }
        
        .max-speed-col,
        .date-col {
            width: 110px;
        }
        
        .horse-name-col {
            width: 140px;
            min-width: 140px;
            white-space: nowrap;
        }
        
        /* Wider horse names on individual horse detail pages */
        .horse-detail-view .horse-name-col {
            width: 260px;
            min-width: 260px;
        }
        
        .date-col {
            width: 85px;
            min-width: 85px;
        }
        
        .fast-recovery-col {
            width: 70px;
            min-width: 70px;
        }
        
        .max-speed-col {
            width: 80px;
            min-width: 80px;
        }
        
        th {
            width: 70px;
            min-width: 70px;
            font-size: 12px;
            font-weight: 600;
        }
        
        td {
            font-size: 12px;
        }

        th {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            color: white;
            font-weight: bold;
            position: sticky;
            top: 0;
            cursor: pointer;
            transition: background 0.3s;
            text-align: center;
        }

        th:hover {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
        }

        tr:nth-child(even) {
            background: #fafbfc;
        }

        tr:hover {
            background: #e8f4fd;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.08);
            transition: all 0.2s ease;
        }
        
        .clickable-row {
            cursor: default;
        }

        .sort-indicator {
            margin-left: 5px;
            opacity: 0.7;
        }

        .time-cell {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #2c3e50;
        }

        .speed-cell {
            color: #e74c3c;
            font-weight: bold;
        }

        .age-cell {
            color: #8e44ad;
            font-weight: bold;
        }
        
        .recovery-cell {
            font-weight: bold;
            color: #2c3e50;
            text-align: center;
        }
        
        .recovery15-cell {
            font-weight: bold;
            color: #2c3e50;
            text-align: center;
        }


        .no-data {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-style: italic;
        }

        .lost-numbers {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-family: 'Courier New', 'IBM Plex Mono', monospace;
            font-size: 11px;
            color: #6a9a7b;
            opacity: 0.75;
            font-weight: normal;
            letter-spacing: 2px;
            user-select: none;
            pointer-events: none;
        }
        
        .horse-detail-view {
            display: none;
        }
        
        .back-button {
            background: #95a5a6;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 15px;
            transition: background 0.3s;
        }
        
        .back-button:hover {
            background: #7f8c8d;
        }
        
        .horse-detail-header {
            background: linear-gradient(135deg, #1a2332 0%, #2c3e50 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .horse-detail-header h1 {
            font-size: 2em;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .workout-row {
            background-color: #fbeaea !important;
        }
        
        .workout-row:hover {
            background-color: #f8e3e3 !important;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(139, 74, 74, 0.1);
        }
        
        .workout-row td {
            background-color: #fbeaea;
            color: #000 !important;
        }
        
        .workout-row:hover td {
            background-color: #f8e3e3;
        }
        
        .workout-row .speed-cell {
            color: #e74c3c !important;
            font-weight: bold;
        }
        
        .workout-row .age-cell {
            color: #8e44ad !important;
            font-weight: bold;
        }
        
        .workout-row .time-cell {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #2c3e50 !important;
        }
        
        .workout-row .recovery-cell {
            font-weight: bold;
            color: #2c3e50 !important;
            text-align: center;
        }
        
        .workout-row .recovery15-cell {
            font-weight: bold;
            color: #2c3e50 !important;
            text-align: center;
        }
        
        .race-row {
            background-color: #e6f3ff !important;
        }
        
        .race-row:hover {
            background-color: #d1e9ff !important;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.1);
        }
        
        .race-row td {
            background-color: #e6f3ff;
            color: #000 !important;
        }
        
        .race-row:hover td {
            background-color: #d1e9ff;
        }
        
        .race-row .speed-cell {
            color: #e74c3c !important;
            font-weight: bold;
        }
        
        .race-row .age-cell {
            color: #8e44ad !important;
            font-weight: bold;
        }
        
        .race-row .time-cell {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #2c3e50 !important;
        }
        
        .race-row .recovery-cell {
            font-weight: bold;
            color: #2c3e50 !important;
            text-align: center;
        }
        
        .race-row .recovery15-cell {
            font-weight: bold;
            color: #2c3e50 !important;
            text-align: center;
        }
        

        /* Calendar popup styles */
        .calendar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .calendar-popup {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #ddd;
            padding-bottom: 15px;
        }

        .calendar-title {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }

        .calendar-nav {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .calendar-nav-btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        .calendar-nav-btn:hover {
            background-color: #2980b9;
        }

        .calendar-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #7f8c8d;
        }

        .calendar-close:hover {
            color: #e74c3c;
        }

        /* Thresholds Modal Styles */
        .thresholds-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .thresholds-modal {
            background: white;
            border-radius: 8px;
            padding: 30px;
            max-width: 800px;
            width: 60%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .thresholds-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
        }

        .thresholds-close:hover {
            color: #000;
        }

        .thresholds-title {
            margin: 0 0 30px 0;
            color: #2c3e50;
            text-align: center;
            font-size: 24px;
        }

        .thresholds-section {
            margin-bottom: 30px;
        }

        .thresholds-section h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 18px;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 8px;
        }

        .thresholds-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        .thresholds-table th,
        .thresholds-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: center;
            font-weight: bold;
        }

        .thresholds-table th {
            background-color: #2c3e50;
            color: white;
            font-size: 14px;
        }

        .thresholds-table td {
            font-size: 13px;
        }

        /* Recovery Tracking Modal Styles */
        .recovery-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .recovery-modal {
            background: white;
            border-radius: 8px;
            padding: 30px;
            max-width: 1400px;
            width: 95%;
            max-height: 95vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .recovery-modal.wide {
            max-width: 1530px;
            width: 83%;
        }

        .recovery-modal.wide .horse-detail-view table {
            min-width: 1530px;
        }

        .recovery-modal.wide #recoveryChartContainer {
            width: 100%;
            min-height: 600px;
        }

        .chart-toggle-btn {
            background: #f5f5f5;
            border: 2px solid #ddd;
            padding: 8px 16px;
            margin: 0 5px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .chart-toggle-btn:hover {
            background: #e8e8e8;
            border-color: #bbb;
        }

        .chart-toggle-btn.active {
            background: #2196F3;
            color: white;
            border-color: #2196F3;
        }

        .chart-toggle-btn.active:hover {
            background: #1976D2;
            border-color: #1976D2;
        }

        .date-filter-btn {
            background: #f9f9f9;
            border: 1px solid #ccc;
            padding: 5px 10px;
            margin: 0 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .date-filter-btn:hover {
            background: #e8e8e8;
            border-color: #999;
        }

        .date-filter-btn.active {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        .date-filter-btn.active:hover {
            background: #45a049;
            border-color: #45a049;
        }

        .recovery-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
        }

        .recovery-close:hover {
            color: #000;
        }

        .recovery-title {
            margin: 0 0 20px 0;
            color: #2c3e50;
            text-align: center;
            font-size: 24px;
        }

        .chart-container {
            position: relative;
            height: 500px;
            width: 100%;
            margin: 20px 0;
        }

        .chart-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background-color: #bdc3c7;
            border: 1px solid #bdc3c7;
        }

        .calendar-day-header {
            background-color: #34495e;
            color: white;
            padding: 10px 5px;
            text-align: center;
            font-weight: bold;
            font-size: 12px;
        }

        .calendar-day {
            background-color: white;
            min-height: 80px;
            padding: 2px;
            position: relative;
            border: 1px solid #ecf0f1;
            display: flex;
            flex-direction: column;
        }

        .calendar-day.other-month {
            background-color: #f8f9fa;
            color: #95a5a6;
        }

        .calendar-day-number {
            font-weight: bold;
            font-size: 10px;
            margin-bottom: 2px;
            padding: 2px;
        }

        .calendar-day.has-events .calendar-day-number {
            font-size: 9px;
            margin-bottom: 1px;
        }

        .calendar-event {
            font-size: 10px;
            padding: 3px 4px;
            margin-bottom: 1px;
            border-radius: 3px;
            line-height: 1.3;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            word-break: break-word;
        }

        .calendar-event.gallop {
            background-color: #fbeaea;
            color: #8e44ad;
            border-left: 3px solid #e74c3c;
        }

        .calendar-event.race {
            background-color: #e6f3ff;
            color: #2980b9;
            border-left: 3px solid #3498db;
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            table {
                font-size: 11px;
            }
            
            /* Keep main page table larger on medium screens */
            #horseTable {
                font-size: 15px;
            }
            
            th, td {
                padding: 8px 10px;
            }
            
            th {
                font-size: 11px;
            }
            
            td {
                font-size: 11px;
            }
            
            .horse-name-col {
                width: 140px;
                min-width: 140px;
                white-space: nowrap;
            }
            
            .horse-detail-view .horse-name-col {
                width: 220px;
                min-width: 220px;
            }
            
            .date-col {
                width: 75px;
                min-width: 75px;
            }
        }
        
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-group {
                width: 100%;
            }
            
            table {
                font-size: 10px;
            }
            
            /* Keep main page table larger on small screens */
            #horseTable {
                font-size: 14px;
            }
            
            th, td {
                padding: 6px 8px;
            }
            
            .horse-name-col {
                width: 120px;
                min-width: 120px;
                white-space: nowrap;
            }
            
            .horse-detail-view .horse-name-col {
                width: 200px;
                min-width: 200px;
            }
            
            .date-col {
                width: 60px;
                min-width: 60px;
            }
            
            .fast-recovery-col, .max-speed-col {
                width: 60px;
                min-width: 60px;
            }
            
            th {
                width: 50px;
                min-width: 50px;
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container" id="mainView">
        <div class="header">
            <h1>Headquarters</h1>
            <p style="font-size: 1.6em; margin: -5px 0 5px 0;">üöÄ</p>
            <p>Analyze horse performance data with interactive sorting and filtering</p>
        </div>


        <div class="controls">
            <div class="control-group file-input">
                <label for="fileInput" class="file-label">üìÅ Upload Excel File</label>
                <input type="file" id="fileInput" accept=".xlsx,.xls,.xlsm,.csv">
            </div>
            
            <div class="control-group">
                <label for="horseFilter">Filter by Horse:</label>
                <input type="text" id="horseFilter" list="horseList" placeholder="Type or select horse name...">
                <datalist id="horseList">
                </datalist>
            </div>
            
            <div class="control-group">
                <label for="ageFilter">Filter by Age:</label>
                <select id="ageFilter">
                    <option value="">All Ages</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="viewFilter" style="font-weight: bold;">View:</label>
                <select id="viewFilter" onchange="changeView()">
                    <option value="best5f">Best 5F Time</option>
                    <option value="best1f">Best 1F Time</option>
                    <option value="maxSpeed">Max Speed</option>
                    <option value="worstFastRecovery">Highest Fast Recovery</option>
                    <option value="worst15minRecovery">Highest 15 Min Recovery</option>
                </select>
            </div>
            
            <div class="control-group">
                <button id="gallopBtn" onclick="showGallopsView()" style="padding: 8px 16px; font-size: 14px; background-color: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">Gallops</button>
            </div>
            
            <div class="control-group">
                <button id="exportCsv" class="export-btn" disabled>üìä Export as CSV</button>
            </div>

            <div class="control-group">
                <button id="thresholdsBtn" class="export-btn">ü§ç Thresholds</button>
            </div>
        </div>

        <div class="table-container">
            <table id="horseTable">
                <thead>
                    <tr>
                        <th onclick="sortTable('name')" class="horse-name-col">Horse <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortTable('age')">Age <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortTable('group')">Group <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortTable('lastGallop')" class="date-col">Last Gallop <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortTable('lastRace')" class="date-col">Last Race <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortTable('valeur')" class="date-col">Valeur <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortTable('dateOfBest5f')" class="date-col">Date of Best 5F <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortTable('best1f')">Time 1F <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortTable('best5f')">Best 5F <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortTable('fastRecovery')" class="fast-recovery-col">Fast <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortTable('recovery15min')">15 min <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortTable('maxSpeed')" class="max-speed-col">Max Speed <span class="sort-indicator">‚Üï</span></th>
                    </tr>
                </thead>
                <tbody id="horseTableBody">
                    <tr>
                        <td colspan="12" class="no-data">No data loaded. Please upload Excel files to get started.</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Horse Detail View -->
    <div class="horse-detail-view" id="horseDetailView">
    <div class="container">
        <div class="horse-detail-header">
            <h1 id="horseDetailTitle">Horse Details</h1>
            <div id="horsePedigreeInfo" style="font-size: 16px; color: white; font-weight: bold; margin-top: 8px; line-height: 1.4;">
                <div id="horsePedigreeText"></div>
                <div id="horseOwnerText" style="margin-top: 4px;"></div>
            </div>
        </div>

        <div class="controls">
            <button class="back-button" onclick="backToMain()">‚Üê Back to Main</button>
            
            <div class="control-group">
                <label for="horseAgeFilter">Filter by Age:</label>
                <select id="horseAgeFilter">
                    <option value="">All Ages</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="horseWorkoutFilter">Filter by Type:</label>
                <select id="horseWorkoutFilter">
                    <option value="all">All Training</option>
                    <option value="gallops">Gallops Only</option>
                    <option value="races">Races Only</option>
                    <option value="gallops-races">Gallops and Races Only</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="horseSortBy">Sort by:</label>
                <select id="horseSortBy">
                    <option value="date">Date</option>
                    <option value="distance">Distance du travail</option>
                    <option value="maxSpeed">Vitesse maximale</option>
                    <option value="avgSpeed">Vitesse moyenne du travail</option>
                    <option value="best200m">Meilleurs 200m</option>
                    <option value="best800m">Meilleurs 800m</option>
                    <option value="best1000m">Meilleurs 1000m</option>
                    <option value="maxHeartRate">Fr√©quence cardiaque maximale</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="horseSortOrder">Order:</label>
                <select id="horseSortOrder">
                    <option value="desc">Descending</option>
                    <option value="asc">Ascending</option>
                </select>
            </div>
            
            <div class="control-group">
                <button id="exportHorseCsv" class="export-btn">üìä Export</button>
            </div>

            <div class="control-group">
                <button id="showCalendar" class="export-btn" onclick="showCalendarPopup()">üìÖ Calendrier</button>
            </div>

            <div class="control-group">
                <button id="showRecoveryTracking" class="export-btn" onclick="showRecoveryTracking()">üìà Recovery</button>
            </div>
        </div>

        <div class="table-container">
            <table id="horseDetailTable">
                <thead>
                    <tr>
                        <th onclick="sortHorseTable('date')">Date <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('cheval')">Cheval <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('age')">√Çge <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('distance')">Distance<br>du travail <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('maxSpeed')">Vitesse<br>maximale <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('avgSpeed')">Vitesse moyenne<br>du travail <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('best200m')">Meilleurs<br>200m <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('best800m')">Meilleurs<br>800m <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('best1000m')">Meilleurs<br>1000m <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('maxHeartRate')">Fr√©quence cardiaque<br>maximale <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('recovery')">R√©cup√©ration<br>apr√®s l'effort <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('recovery15min')">15 min<br>r√©cup√©ration <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('heartRateReturn')">Fr√©quence cardiaque<br>au retour <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('amplitude35')">Amplitude<br>√† 35 km/h <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('effort1')">Temps zone<br>effort 1 <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('effort2')">Temps zone<br>effort 2 <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('effort3')">Temps zone<br>effort 3 <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('effort4')">Temps zone<br>effort 4 <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortHorseTable('effort5')">Temps zone<br>effort 5 <span class="sort-indicator">‚Üï</span></th>
                    </tr>
                </thead>
                <tbody id="horseDetailTableBody">
                    <tr>
                        <td colspan="19" class="no-data">No data loaded for this horse.</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Weekly Performance Averages -->
    <div id="weeklyAveragesContainer" class="horse-detail-view" style="display: none; margin-top: 30px;">
        <div class="container">
            <h2 style="text-align: center; color: #2c3e50; margin-bottom: 20px;">üìä Weekly Performance Averages (Fast Times ‚â§ 1:30)</h2>

            <div class="table-container">
                <table id="weeklyAveragesTable" style="margin: 0 auto; max-width: 800px;">
                    <thead>
                        <tr>
                            <th style="width: 25%;">Week</th>
                            <th style="width: 15%;">Sessions</th>
                            <th style="width: 20%;">Avg 1000m</th>
                            <th style="width: 20%;">Fast Rec.</th>
                            <th style="width: 20%;">15min Rec.</th>
                        </tr>
                    </thead>
                    <tbody id="weeklyAveragesBody">
                        <tr>
                            <td colspan="5" class="no-data">No weekly data available.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p style="font-size: 11px; color: #666; text-align: center; margin-top: 10px; font-style: italic;">
                *This table excludes gallops
            </p>
        </div>
    </div>
    </div>

    <!-- Gallops Comparison View -->
    <div id="gallopView" class="horse-detail-view" style="display: none;">
        <div class="detail-header">
            <h2 id="gallopViewTitle" class="detail-title" style="color: white;">Gallops Comparison - [Date]</h2>
            <p style="margin: 5px 0; color: #ccc; font-size: 14px;" id="gallopViewSubtitle">All horses that galloped on this date</p>
        </div>
        
        <div class="container" style="margin-top: 0; padding-top: 20px;">
            <div class="detail-controls" style="margin-bottom: 30px; display: flex; align-items: center; gap: 15px;">
                <div class="control-group">
                    <label for="gallopDateFilter">Date de Galop:</label>
                    <select id="gallopDateFilter" onchange="changeGallopDate()">
                        <!-- Dates will be populated by JavaScript -->
                    </select>
                </div>
                
                <div class="control-group">
                    <button onclick="backToMainFromGallops()" class="back-button">‚Üê Back to Main</button>
                </div>
                
                <div class="control-group">
                    <button onclick="exportGallopsCsv()" class="export-btn">üìä Export as CSV</button>
                </div>
                
                <div class="control-group">
                </div>
            </div>
            <div class="table-container">
            <table id="gallopTable">
                <thead>
                    <tr>
                        <th onclick="sortGallopTable('horse')" class="horse-name-col" style="cursor: pointer; width: 140px; min-width: 140px; white-space: nowrap;">Cheval <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('age')" style="cursor: pointer;">√Çge <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('group')" style="cursor: pointer;">Group <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('distance')" style="cursor: pointer;">Distance<br>du travail <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('maxSpeed')" style="cursor: pointer;">Vitesse<br>maximale <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('avgSpeed')" style="cursor: pointer;">Vitesse moyenne<br>du travail <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('best200m')" style="cursor: pointer;">Meilleurs<br>200m <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('best800m')" style="cursor: pointer;">Meilleurs<br>800m <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('best5f')" style="cursor: pointer;">Meilleurs<br>1000m <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('maxHeartRate')" style="cursor: pointer;">Fr√©quence cardiaque<br>maximale atteinte <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('fastRecovery')" style="cursor: pointer;">R√©cup√©ration<br>apr√®s l'effort <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('recovery15min')" style="cursor: pointer;">15 min<br>r√©cup√©ration <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('heartRateReturn')" style="cursor: pointer;">Fr√©quence cardiaque<br>au retour <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('amplitude35')" style="cursor: pointer;">Amplitude<br>√† 35 km/h <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('effort1')" style="cursor: pointer;">Temps zone<br>effort 1 <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('effort2')" style="cursor: pointer;">Temps zone<br>effort 2 <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('effort3')" style="cursor: pointer;">Temps zone<br>effort 3 <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('effort4')" style="cursor: pointer;">Temps zone<br>effort 4 <span class="sort-indicator">‚Üï</span></th>
                        <th onclick="sortGallopTable('effort5')" style="cursor: pointer;">Temps zone<br>effort 5 <span class="sort-indicator">‚Üï</span></th>
                    </tr>
                </thead>
                <tbody id="gallopTableBody">
                    <!-- Gallop data will be populated here -->
                </tbody>
            </table>
            </div>
        </div>
    </div>


    <!-- Calendar Popup -->
    <div class="calendar-overlay" id="calendarOverlay">
        <div class="calendar-popup">
            <button class="calendar-close" onclick="hideCalendarPopup()">&times;</button>
            
            <div class="calendar-header">
                <div class="calendar-title" id="calendarTitle">Calendrier d'Entra√Ænement</div>
                <div class="calendar-nav">
                    <button class="calendar-nav-btn" onclick="previousMonth()" style="padding: 4px 8px; font-size: 12px;">‚Üê Pr√©c√©dent</button>
                    <div id="currentMonthYear" style="font-weight: bold; font-size: 18px;"></div>
                    <button class="calendar-nav-btn" onclick="nextMonth()" style="padding: 4px 8px; font-size: 12px;">Suivant ‚Üí</button>
                    <button class="calendar-nav-btn" onclick="exportCalendarToPDF()" style="background-color: #2196F3; color: white; padding: 4px 8px; font-size: 12px;">Export PDF</button>
                </div>
            </div>
            
            <div class="calendar-grid" id="calendarGrid">
                <!-- Calendar will be generated here -->
            </div>
        </div>
    </div>

    <!-- Thresholds Modal -->
    <div class="thresholds-overlay" id="thresholdsOverlay">
        <div class="thresholds-modal">
            <button class="thresholds-close" onclick="hideThresholdsModal()">&times;</button>

            <h2 class="thresholds-title">Seuils Cardiologiques et Temporels</h2>

            <!-- Fast Recovery Thresholds -->
            <div class="thresholds-section">
                <h3>Seuils de R√©cup√©ration Rapide (Fast Recovery)</h3>
                <table class="thresholds-table">
                    <thead>
                        <tr>
                            <th>Couleur</th>
                            <th>Plage de Valeurs</th>
                            <th>√âvaluation</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="background-color: #d1ecf1; color: #000;">Bleu</td>
                            <td>< 101</td>
                            <td>Excellente r√©cup√©ration</td>
                        </tr>
                        <tr>
                            <td style="background-color: #d4edda; color: #000;">Vert</td>
                            <td>101 - 118</td>
                            <td>Bonne r√©cup√©ration</td>
                        </tr>
                        <tr>
                            <td style="background-color: #f9f7e3; color: #000;">Jaune clair</td>
                            <td>119 - 124</td>
                            <td>R√©cup√©ration mod√©r√©e</td>
                        </tr>
                        <tr>
                            <td style="background-color: #fff3cd; color: #000;">Jaune</td>
                            <td>125 - 139</td>
                            <td>R√©cup√©ration lente</td>
                        </tr>
                        <tr>
                            <td style="background-color: #fdeaea; color: #000;">Rouge</td>
                            <td>‚â• 140</td>
                            <td>R√©cup√©ration tr√®s lente</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- 15 Min Recovery Thresholds -->
            <div class="thresholds-section">
                <h3>Seuils de R√©cup√©ration √† 15 Minutes</h3>
                <table class="thresholds-table">
                    <thead>
                        <tr>
                            <th>Couleur</th>
                            <th>Plage de Valeurs</th>
                            <th>√âvaluation</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="background-color: #d1ecf1; color: #000;">Bleu</td>
                            <td>< 81</td>
                            <td>Excellente r√©cup√©ration</td>
                        </tr>
                        <tr>
                            <td style="background-color: #d4edda; color: #000;">Vert</td>
                            <td>81 - 101</td>
                            <td>Bonne r√©cup√©ration</td>
                        </tr>
                        <tr>
                            <td style="background-color: #fff3cd; color: #000;">Jaune</td>
                            <td>102 - 115</td>
                            <td>R√©cup√©ration mod√©r√©e</td>
                        </tr>
                        <tr>
                            <td style="background-color: #fdeaea; color: #000;">Rouge</td>
                            <td>‚â• 116</td>
                            <td>R√©cup√©ration lente</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- 5F Time Thresholds -->
            <div class="thresholds-section">
                <h3>Seuils de Temps sur 1000m (5F)</h3>
                <table class="thresholds-table">
                    <thead>
                        <tr>
                            <th>Couleur</th>
                            <th>Plage de Temps</th>
                            <th>√âvaluation</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="background-color: #d1ecf1; color: #000;">Bleu</td>
                            <td>< 1:03.00</td>
                            <td>Excellent</td>
                        </tr>
                        <tr>
                            <td style="background-color: #d4edda; color: #000;">Vert</td>
                            <td>1:03.00 - 1:10.99</td>
                            <td>Bon</td>
                        </tr>
                        <tr>
                            <td style="background-color: #f9f7e3; color: #000;">Jaune clair</td>
                            <td>1:11.00 - 1:49.99</td>
                            <td>Mod√©r√©</td>
                        </tr>
                        <tr>
                            <td style="background-color: #fdeaea; color: #000;">Rouge</td>
                            <td>‚â• 1:50.00</td>
                            <td>Lent</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Recovery Tracking Modal -->
    <div class="recovery-overlay" id="recoveryOverlay">
        <div class="recovery-modal">
            <button class="recovery-close" onclick="hideRecoveryTracking()">&times;</button>

            <h2 class="recovery-title" id="recoveryModalTitle">Recovery Tracking</h2>


            <div class="chart-controls" style="margin-bottom: 20px; text-align: center;">
                <div style="margin-bottom: 10px;">
                    <button id="fastDaysToggle" class="chart-toggle-btn active" onclick="toggleChartData('fast')">
                        Fast Days Only (‚â§1:30)
                    </button>
                    <button id="allDaysToggle" class="chart-toggle-btn" onclick="toggleChartData('all')">
                        All Training Days (‚â§3:00)
                    </button>
                </div>
                <div>
                    <label style="font-weight: bold; margin-right: 10px;">Date Range:</label>
                    <button id="dateAll" class="date-filter-btn active" onclick="setDateFilter('all')">All Time</button>
                    <button id="date30" class="date-filter-btn" onclick="setDateFilter(30)">30 Days</button>
                    <button id="date60" class="date-filter-btn" onclick="setDateFilter(60)">60 Days</button>
                    <button id="date90" class="date-filter-btn" onclick="setDateFilter(90)">90 Days</button>
                    <button id="date180" class="date-filter-btn" onclick="setDateFilter(180)">6 Months</button>
                </div>
            </div>

            <div class="chart-container">
                <canvas id="recoveryChart"></canvas>
            </div>

            <div style="margin-top: 20px; font-size: 13px; color: #666; text-align: center; line-height: 1.3;">
                <p><strong>Chart Rules:</strong></p>
                <p>‚Ä¢ Recovery trend lines show weekly averages (7-day periods) ‚Ä¢ Gallops are not included in recovery trend lines (shown as individual points)</p>
                <p>‚Ä¢ When "fast" filter is active, only sessions ‚â§1:30 are included in recovery averages</p>
                <p>‚Ä¢ Red dashed lines indicate training breaks of 21+ days ‚Ä¢ Recovery trend lines break at training gaps to show training periods</p>
            </div>

            <!-- Weekly Performance Averages in Modal -->
            <div style="margin-top: 30px; border-top: 2px solid #ddd; padding-top: 20px;">
                <h3 style="text-align: center; color: #2c3e50; margin-bottom: 15px;">üìä Weekly Performance Averages (Fast Times ‚â§ 1:30)</h3>

                <div style="max-height: 500px; overflow-y: auto;">
                    <table id="weeklyAveragesModalTable" style="margin: 0 auto; font-size: 13px; max-width: 700px;">
                        <thead>
                            <tr>
                                <th style="font-size: 12px; padding: 8px; width: 25%;">Week</th>
                                <th style="font-size: 12px; padding: 8px; width: 15%;">Sessions</th>
                                <th style="font-size: 12px; padding: 8px; width: 20%;">Avg 1000m</th>
                                <th style="font-size: 12px; padding: 8px; width: 20%;">Fast Rec.</th>
                                <th style="font-size: 12px; padding: 8px; width: 20%;">15min Rec.</th>
                            </tr>
                        </thead>
                        <tbody id="weeklyAveragesModalBody">
                            <tr>
                                <td colspan="5" class="no-data">No weekly data available.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p style="font-size: 11px; color: #666; text-align: center; margin-top: 10px; font-style: italic;">
                    *This table excludes gallops
                </p>
            </div>
        </div>
    </div>

    <script>
        let horseData = [];
        let filteredData = [];
        let currentSort = { column: 'name', order: 'asc' };
        let allHorseDetailData = {};
        let currentHorseDetailData = [];
        let currentHorseDetailSort = { column: 'date', order: 'desc' };
        let horseColorMapping = {}; // Maps horse names to their color group
        let horsePedigreeMapping = {}; // Maps horse names to pedigree info
        let currentWorkbook = null;
        let greenHorses = []; // Column C horses (Group A)
        let orangeHorses = []; // Column D horses (Group B)
        let lightRedHorses = []; // Column E horses (Group C)
        
        function processSheet2ColorMapping() {
            console.log('=== SIMPLE Sheet2 Reading ===');

            if (!currentWorkbook || !currentWorkbook.Sheets['Sheet2']) {
                console.log('No Sheet2 found, skipping color mapping');
                greenHorses = [];
                orangeHorses = [];
                lightRedHorses = [];
                horseColorMapping = {};
                horsePedigreeMapping = {};
                return;
            }

            // Clear arrays
            greenHorses = [];
            orangeHorses = [];
            lightRedHorses = [];
            horseColorMapping = {};
            horsePedigreeMapping = {};

            const sheet = currentWorkbook.Sheets['Sheet2'];
            
            console.log('Sheet2 range:', sheet['!ref']);
            console.log('Checking direct cell access:');
            
            // Check what's actually in the cells directly - look for headers and pedigree info
            for (let row = 1; row <= 5; row++) {
                console.log(`Direct cell access for row ${row}:`);
                console.log(`  A${row}:`, sheet[`A${row}`] ? sheet[`A${row}`].v : 'empty');
                console.log(`  B${row}:`, sheet[`B${row}`] ? sheet[`B${row}`].v : 'empty');
                console.log(`  C${row}:`, sheet[`C${row}`] ? sheet[`C${row}`].v : 'empty');
                console.log(`  D${row}:`, sheet[`D${row}`] ? sheet[`D${row}`].v : 'empty');
                console.log(`  E${row}:`, sheet[`E${row}`] ? sheet[`E${row}`].v : 'empty');
                console.log(`  F${row}:`, sheet[`F${row}`] ? sheet[`F${row}`].v : 'empty');
                console.log(`  G${row}:`, sheet[`G${row}`] ? sheet[`G${row}`].v : 'empty');
                console.log(`  H${row}:`, sheet[`H${row}`] ? sheet[`H${row}`].v : 'empty');
                console.log(`  I${row}:`, sheet[`I${row}`] ? sheet[`I${row}`].v : 'empty');
                console.log(`  J${row}:`, sheet[`J${row}`] ? sheet[`J${row}`].v : 'empty');
            }
            
            // First, find the "Effectif" section for pedigree information
            console.log('Looking for "Effectif" section for pedigree information...');
            let effectifStartRow = null;

            // Scan for "Effectif" in column A
            for (let scanRow = 1; scanRow <= 100; scanRow++) {
                const cellA = sheet[`A${scanRow}`];
                if (cellA && cellA.v && cellA.v.toString().toLowerCase().includes('effectif')) {
                    effectifStartRow = scanRow + 1; // Start reading data from next row
                    console.log(`Found "Effectif" at row ${scanRow}, data starts at row ${effectifStartRow}`);
                    break;
                }
            }

            // Extract pedigree information from Effectif section
            if (effectifStartRow) {
                console.log('Reading pedigree data from Effectif section...');
                let pedigreeRow = effectifStartRow;

                while (pedigreeRow < effectifStartRow + 50) { // Read up to 50 horses
                    const cellA = sheet[`A${pedigreeRow}`];
                    const cellB = sheet[`B${pedigreeRow}`];
                    const cellC = sheet[`C${pedigreeRow}`];
                    const cellD = sheet[`D${pedigreeRow}`];
                    const cellE = sheet[`E${pedigreeRow}`];

                    // If column A is empty, we've reached the end of the Effectif section
                    if (!cellA || !cellA.v || cellA.v.toString().trim() === '') {
                        break;
                    }

                    const horseName = cellA.v.toString().trim();
                    const sire = cellB?.v ? cellB.v.toString().trim() : '';
                    const dam = cellC?.v ? cellC.v.toString().trim() : '';
                    const broodmareSire = cellD?.v ? cellD.v.toString().trim() : '';
                    const owner = cellE?.v ? cellE.v.toString().trim() : '';

                    // Store pedigree information
                    horsePedigreeMapping[horseName] = {
                        sire: sire,
                        dam: dam,
                        broodmareSire: broodmareSire,
                        owner: owner
                    };

                    if (pedigreeRow <= effectifStartRow + 5) {
                        console.log(`  Pedigree data for ${horseName}:`, {
                            sire: sire,
                            dam: dam,
                            broodmareSire: broodmareSire,
                            owner: owner
                        });
                    }

                    pedigreeRow++;
                }
                console.log(`Loaded pedigree data for ${Object.keys(horsePedigreeMapping).length} horses`);
            } else {
                console.log('No "Effectif" section found in Sheet2');
            }

            // Now read color mapping from the original location (columns C, D, E from top)
            const startRow = 2; // Skip header
            let row = startRow;

            console.log('Reading horses from columns C, D, E for color mapping...');
            
            while (true) {
                const cellC = sheet[`C${row}`];
                const cellD = sheet[`D${row}`];
                const cellE = sheet[`E${row}`];

                // If all cells are empty, we've reached the end
                if (!cellC && !cellD && !cellE) {
                    break;
                }

                // Column C - Group A (Green)
                if (cellC && cellC.v) {
                    const name = cellC.v.toString().trim().toUpperCase();
                    if (name) {
                        greenHorses.push(name);
                        horseColorMapping[name] = 'green';
                        if (row <= 6) console.log(`  Added to GROUP A (GREEN) from Column C${row}: "${name}"`);
                    }
                }

                // Column D - Group B (Orange)
                if (cellD && cellD.v) {
                    const name = cellD.v.toString().trim().toUpperCase();
                    if (name) {
                        orangeHorses.push(name);
                        horseColorMapping[name] = 'orange';
                        if (row <= 6) console.log(`  Added to GROUP B (ORANGE) from Column D${row}: "${name}"`);
                    }
                }

                // Column E - Group C (Light Red)
                if (cellE && cellE.v) {
                    const name = cellE.v.toString().trim().toUpperCase();
                    if (name) {
                        lightRedHorses.push(name);
                        horseColorMapping[name] = 'light-red';
                        if (row <= 6) console.log(`  Added to GROUP C (LIGHT RED) from Column E${row}: "${name}"`);
                    }
                }
                
                row++;
                
                // Safety check to prevent infinite loop
                if (row > 1000) break;
            }
            
            console.log('=== SHEET2 VERIFICATION ===');
            console.log('A Group (Green) - Count:', greenHorses.length, 'First 3:', greenHorses.slice(0, 3));
            console.log('B Group (Orange) - Count:', orangeHorses.length, 'First 3:', orangeHorses.slice(0, 3));
            console.log('C Group (Light Red) - Count:', lightRedHorses.length, 'First 3:', lightRedHorses.slice(0, 3));
            
            // Test a few specific horses to verify lookup works
            console.log('=== GROUP LOOKUP VERIFICATION ===');
            if (greenHorses.length > 0) {
                const testGreen = greenHorses[0];
                console.log(`Test Green Horse: "${testGreen}" -> Group: ${getHorseGroup(testGreen)}`);
            }
            if (orangeHorses.length > 0) {
                const testOrange = orangeHorses[0];
                console.log(`Test Orange Horse: "${testOrange}" -> Group: ${getHorseGroup(testOrange)}`);
            }
            if (lightRedHorses.length > 0) {
                const testRed = lightRedHorses[0];
                console.log(`Test Light Red Horse: "${testRed}" -> Group: ${getHorseGroup(testRed)}`);
            }
        }
        
        function getHorseNameColor(horseName) {
            const group = getHorseGroup(horseName);
            if (!group || group === '-') return '';
            
            // Use the "most forward" color (highest priority)
            // A (green) > B (orange) > C (light red)
            if (group.includes('A')) {
                return 'background-color: #d4edda; color: #000;'; // Green wins
            } else if (group.includes('B')) {
                return 'background-color: #fff3cd; color: #000;'; // Orange wins  
            } else if (group.includes('C')) {
                return 'background-color: #f8d7da; color: #000;'; // Light red
            }
            
            return '';
        }
        
        function getHorseGroup(horseName) {
            // Use the dynamically loaded global arrays from Sheet2
            const groups = [];

            // Convert to uppercase for comparison since we store them as uppercase
            const upperCaseName = horseName.toUpperCase();

            if (greenHorses.includes(upperCaseName)) groups.push('A');
            if (orangeHorses.includes(upperCaseName)) groups.push('B');
            if (lightRedHorses.includes(upperCaseName)) groups.push('C');

            const result = groups.length > 0 ? groups.join('/') : '-';

            return result;
        }

        function getHorsePedigree(horseName) {
            // Look for exact match first
            if (horsePedigreeMapping[horseName]) {
                return horsePedigreeMapping[horseName];
            }

            // Try case-insensitive match
            const lowerCaseName = horseName.toLowerCase();
            for (const key in horsePedigreeMapping) {
                if (key.toLowerCase() === lowerCaseName) {
                    return horsePedigreeMapping[key];
                }
            }

            // Return empty object if not found
            return {
                sire: '',
                dam: '',
                broodmareSire: '',
                owner: ''
            };
        }
        
        function getFastRecoveryColor(value) {
            if (!value || value === 'N/A') return null;
            
            const numValue = parseFloat(value);
            if (isNaN(numValue)) return null;
            
            if (numValue >= 140) return '#fdeaea';
            if (numValue >= 125) return '#fff3cd';
            if (numValue >= 119) return '#f9f7e3';
            if (numValue >= 101) return '#d4edda';
            return '#d1ecf1';
        }
        
        function getRecovery15Color(value) {
            if (!value || value === 'N/A') return null;
            
            const numValue = parseFloat(value);
            if (isNaN(numValue)) return null;
            
            if (numValue >= 116) return '#fdeaea';
            if (numValue >= 102) return '#fff3cd';
            if (numValue >= 81) return '#d4edda';
            return '#d1ecf1';
        }
        
        function get1000mTimeColor(timeStr) {
            if (!timeStr || timeStr === 'N/A' || !isValidTime(timeStr)) return null;
            
            const seconds = timeToSeconds(timeStr);
            
            if (seconds < 63) return '#d1ecf1';     // Blue - below 1:03.00
            if (seconds < 71) return '#d4edda';     // Green - 1:03.00 to 1:11.00
            if (seconds < 110) return '#f9f7e3';   // Light yellow - 1:11.00 to 1:50.00
            return '#fdeaea';                       // Red - 1:50.00 and higher
        }

        console.log("üêé Horse Racing Analyzer loaded successfully!");

        // Helper function for consistent European date formatting
        function formatDateEuropean(date) {
            if (!date) return '';
            const dateObj = date instanceof Date ? date : new Date(date);
            if (isNaN(dateObj.getTime())) return '';
            return dateObj.toLocaleDateString('fr-FR'); // DD/MM/YYYY format
        }

        // Helper function to parse European date strings (DD/MM/YYYY) correctly
        function parseEuropeanDate(dateStr) {
            if (!dateStr) return null;

            // If it's already a Date object, return it
            if (dateStr instanceof Date) return dateStr;

            // Handle DD/MM/YYYY format
            const parts = dateStr.toString().split('/');
            if (parts.length === 3) {
                const day = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed in JavaScript
                const year = parseInt(parts[2], 10);

                // Handle 2-digit years
                const fullYear = year < 100 ? (year > 50 ? 1900 + year : 2000 + year) : year;

                return new Date(fullYear, month, day);
            }

            // Fallback to standard parsing
            return new Date(dateStr);
        }

        // France Galop URL generation functions
        function generateRaceUrl(date, track) {
            // For France Galop race detail pages
            // Pattern: https://www.france-galop.com/fr/course/detail/YYYY/P/[encoded-id]
            // Since we can't determine the exact encoded ID, we'll use a simplified approach
            // that at least gets users to the right date/track area
            
            if (!date || !track) return null;
            
            const year = new Date(date).getFullYear();
            // This is a simplified URL - the actual encoded ID would need to be extracted from the original Excel
            // For now, this gets users to France Galop races for the year
            return `https://www.france-galop.com/fr/course/programmes?date=${date}&hippodrome=${track}`;
        }
        
        function generateTrackingReportUrl(date, track, raceNumber) {
            // For France Galop tracking reports
            // Pattern: https://www7.france-galop.com/Casaques/Tracking/YYYYMMDDXXX##_last_times_fr.pdf
            
            if (!date || !track) return null;
            
            const dateObj = new Date(date);
            const year = dateObj.getFullYear();
            const month = String(dateObj.getMonth() + 1).padStart(2, '0');
            const day = String(dateObj.getDate()).padStart(2, '0');
            const dateStr = `${year}${month}${day}`;
            
            // Map track names to codes (add more as needed)
            const trackCodes = {
                'deauville': 'DEA',
                'saint-cloud': 'SCL',
                'longchamp': 'LON',
                'chantilly': 'CHA',
                'maisons-laffitte': 'MAL'
            };
            
            const trackCode = trackCodes[track.toLowerCase()] || 'DEA';
            const raceNum = raceNumber || '02'; // Default to race 2 if not specified
            
            return `https://www7.france-galop.com/Casaques/Tracking/${dateStr}${trackCode}${raceNum}_last_times_fr.pdf`;
        }
        
        function extractTrackFromRecoveryText(recoveryText) {
            // Extract track name from race result text
            if (!recoveryText || typeof recoveryText !== 'string') return null;
            
            const trackIndicators = ['deauville', 'saint-cloud', 'longchamp', 'chantilly', 'maisons-laffitte'];
            const lowerText = recoveryText.toLowerCase();
            
            return trackIndicators.find(track => lowerText.includes(track)) || null;
        }
        
        function extractRaceNumberFromText(recoveryText) {
            // Try to extract race number from text like "G3" or "C1" etc.
            if (!recoveryText || typeof recoveryText !== 'string') return '02';
            
            const match = recoveryText.match(/([GC]\d+)/i);
            return match ? '0' + match[1].charAt(1) : '02';
        }
        
        function cleanNCValue(value) {
            // Replace N/C (case insensitive) with dash
            if (value === 'N/C' || value === 'n/c' || value === 'N/c' || value === 'n/C') {
                return '-';
            }
            return value || '-';
        }
        
        document.getElementById('fileInput').addEventListener('change', handleFileUpload);
        document.getElementById('horseFilter').addEventListener('input', filterData);
        document.getElementById('ageFilter').addEventListener('change', filterData);
        document.getElementById('exportCsv').addEventListener('click', exportToCsv);
        document.getElementById('thresholdsBtn').addEventListener('click', showThresholdsModal);

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            console.log('File selected:', file.name);
            console.log('Starting file upload process...');
            horseData = [];
            
            // Clear previous workbook and color mapping data
            currentWorkbook = null;
            const prevGreenCount = greenHorses.length;
            const prevOrangeCount = orangeHorses.length;
            const prevRedCount = lightRedHorses.length;
            greenHorses = [];
            orangeHorses = [];
            lightRedHorses = [];
            horseColorMapping = {};
            console.log(`=== DATA CLEARING VERIFICATION ===`);
            console.log(`Cleared previous data: Green(${prevGreenCount}), Orange(${prevOrangeCount}), Red(${prevRedCount})`);
            console.log('Arrays now empty:', greenHorses.length === 0 && orangeHorses.length === 0 && lightRedHorses.length === 0);
            
            const reader = new FileReader();
            const fileName = file.name.toLowerCase();
            const isCSV = fileName.endsWith('.csv');
            
            reader.onload = function(e) {
                if (isCSV) {
                    const csvText = e.target.result;
                    const jsonData = parseCSV(csvText);
                    const horseName = fileName.replace('.csv', '').replace(/[^a-zA-Z0-9]/g, ' ').trim() || 'Horse';
                    const horseStats = processSheetData(jsonData, horseName, null, null);
                    if (horseStats) {
                        horseData.push(horseStats);
                    }
                } else {
                    try {
                        const data = new Uint8Array(e.target.result);
                        currentWorkbook = XLSX.read(data, {
                            type: 'array', 
                            cellStyles: true, 
                            cellHTML: true,
                            cellFormula: true, 
                            bookSST: true,
                            cellNF: true,
                            cellDates: true,
                            raw: false
                        });
                        
                        console.log('Workbook loaded. Sheet names:', currentWorkbook.SheetNames);
                        
                        currentWorkbook.SheetNames.forEach(sheetName => {
                            const sheetNameLower = sheetName.toLowerCase();
                            if (sheetNameLower === 'sheet1' || sheetNameLower === 'sheet2' || sheetNameLower === 'buttons') {
                                return;
                            }
                            
                            const worksheet = currentWorkbook.Sheets[sheetName];
                            if (!worksheet) return;
                            
                            const jsonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});
                            const horseStats = processSheetData(jsonData, sheetName, worksheet, currentWorkbook);
                            if (horseStats) {
                                horseData.push(horseStats);
                            }
                        });
                    } catch (error) {
                        console.error('Error processing Excel file:', error);
                        alert('Error processing Excel file: ' + error.message);
                        return;
                    }
                }
                
                // Process Sheet2 for horse color mapping (works for Excel files with Sheet2)
                if (currentWorkbook && currentWorkbook.Sheets['Sheet2']) {
                    console.log('>>> ABOUT TO CALL processSheet2ColorMapping()');
                    processSheet2ColorMapping();
                    console.log('>>> FINISHED CALLING processSheet2ColorMapping()');
                    
                    // Force complete table rebuild to show updated groups
                    console.log('>>> REBUILDING TABLE TO SHOW GROUPS');
                    console.log('Horse data count before update:', horseData.length);
                    
                    // Update all existing horse data with new group information
                    let updatedCount = 0;
                    horseData.forEach(horse => {
                        const oldGroup = horse.group;
                        horse.group = getHorseGroup(horse.name);
                        if (oldGroup !== horse.group) {
                            updatedCount++;
                        }
                    });
                    
                    console.log(`Updated ${updatedCount} horses with new group assignments`);
                    
                    // Force table refresh
                    filterData();
                } else {
                    console.log('Sheet2 not available - using default color mapping');
                    // Initialize empty arrays for CSV files or Excel files without Sheet2
                    greenHorses = [];
                    orangeHorses = [];
                    lightRedHorses = [];
                    horseColorMapping = {};
                    horsePedigreeMapping = {};
                }
                
                updateHorseFilter();
                updateAgeFilter();
                filterData();
                document.getElementById('exportCsv').disabled = false;
            };
            
            if (isCSV) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n');
            const result = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line) {
                    const row = [];
                    let current = '';
                    let inQuotes = false;
                    
                    for (let j = 0; j < line.length; j++) {
                        const char = line[j];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            row.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    row.push(current.trim());
                    result.push(row);
                }
            }
            
            return result;
        }
        
        function processSheetData(jsonData, horseName, worksheet, workbook) {
            if (jsonData.length === 0) return null;
            
            const headers = jsonData[0].map(h => h ? h.toString().toLowerCase().trim() : '');
            console.log(`Processing sheet: ${horseName}`);
            
            let age = null;
            let best1f = null;
            let best5f = null;
            let dateOfBest5f = null;
            let dateOfBest1f = null;
            let best1fRecovery = null;
            let best1fRecovery15min = null;
            let best1fRecoveryColor = null;
            let best1fRecovery15Color = null;
            let best1fCorresponding5f = null;
            let best1fMaxSpeed = null;
            let best5fMaxSpeed = null;
            let best5fCorresponding1f = null;
            let maxSpeed = null;
            let dateOfMaxSpeed = null;
            let maxSpeedRecovery = null;
            let maxSpeedRecovery15min = null;
            let maxSpeedRecoveryColor = null;
            let maxSpeedRecovery15Color = null;
            let maxSpeedCorresponding1f = null;
            let maxSpeedCorresponding5f = null;
            let fastRecovery = null;
            let recovery15min = null;
            let fastRecoveryColor = null;
            let recovery15Color = null;
            
            const times1f = [];
            const times5f = [];
            const speeds = [];
            const maxSpeeds = [];
            const detailData = [];
            const gallopDates = [];
            const raceDates = [];
            const raceValeurs = []; // Store {date, valeur} for races
            
            for (let i = 1; i < jsonData.length; i++) {
                const row = jsonData[i];
                if (!row || row.length === 0) continue;
                
                const rowData = {};
                headers.forEach((header, index) => {
                    rowData[header] = row[index] ? row[index].toString().trim() : '';
                });
                
                let dateValue = row[0] || rowData.date || rowData.timestamp || rowData['race date'] || '';
                let rawDateObject = null; // Keep the original Date object for calculations

                if (typeof dateValue === 'number' && dateValue > 40000) {
                    const excelEpoch = new Date(1899, 11, 30);
                    const jsDate = new Date(excelEpoch.getTime() + dateValue * 24 * 60 * 60 * 1000);
                    rawDateObject = jsDate;
                    dateValue = formatDateEuropean(jsDate);
                } else if (dateValue instanceof Date) {
                    rawDateObject = dateValue;
                    dateValue = formatDateEuropean(dateValue);
                } else if (dateValue.toString().includes('T')) {
                    const date = new Date(dateValue);
                    rawDateObject = date;
                    dateValue = formatDateEuropean(date);
                } else if (dateValue) {
                    // Try to parse as European date string first (DD/MM/YYYY)
                    const parsedDate = parseEuropeanDate(dateValue);
                    if (parsedDate && !isNaN(parsedDate.getTime())) {
                        rawDateObject = parsedDate;
                        dateValue = formatDateEuropean(parsedDate);
                    }
                }
                
                // No gallop detection - removed as requested
                
                // Check for hyperlinks in date and horse name cells
                let dateHyperlink = null;
                let horseHyperlink = null;
                
                if (worksheet && worksheet['!ref']) {
                    const range = XLSX.utils.decode_range(worksheet['!ref']);
                    // Check date cell (first column)
                    const dateCell = worksheet[XLSX.utils.encode_cell({r: i, c: 0})];
                    if (dateCell && dateCell.l) {
                        dateHyperlink = dateCell.l.Target || dateCell.l.target;
                    }
                    
                    // Check horse name cell (second column)
                    const horseCell = worksheet[XLSX.utils.encode_cell({r: i, c: 1})];
                    if (horseCell && horseCell.l) {
                        horseHyperlink = horseCell.l.Target || horseCell.l.target;
                    }
                }
                
                // Detect workouts and race results based on multiple criteria
                let isWorkout = false;
                let isRaceResult = false;
                
                const distance = parseFloat(rowData['distance du travail'] || rowData['distance'] || '0');
                const maxSpeed = parseFloat(rowData['vitesse maximale'] || rowData['max speed'] || '0');
                const recovery = (rowData['r√©cup√©ration apr√®s l\'effort'] || rowData['fast recovery'] || '').toString().toLowerCase();
                const maxHeartRate = parseFloat(rowData['fr√©quence cardiaque maximale atteinte'] || rowData['max heart rate'] || '0');
                const avgSpeed = parseFloat(rowData['vitesse moyenne du travail'] || rowData['avg speed'] || '0');
                
                // Simplified race detection logic - focus on hyperlinks and recovery text patterns
                
                // 1. If there's a hyperlink, it's definitely a race
                if (dateHyperlink || horseHyperlink) {
                    isRaceResult = true;
                }
                
                // 2. Check fast recovery column for race indicators
                // Define race patterns outside the if block for debugging
                const racePatterns = [
                    // Track names
                    /\b(deauville|saint-cloud|vichy|longchamp|chantilly|maisons-laffitte|lyon-parilly|compiegne|fontainebleau)\b/i,
                    // Race classifications
                    /\b(c[1-5]|g[1-3]|l|prix|listed|group)\b/i,
                    // Finishing positions (number followed by position indicator)
                    /\b(\d+)(er|√®me|st|nd|rd|th)\b/i,
                    // Race result terms
                    /\b(gagn√©|gagnant|plac√©|arriv√©|course|psf|turf)\b/i,
                    // Distance + track combination (e.g. "1200 deauville")
                    /\d{4}\s+\w+/
                ];
                
                if (!isRaceResult && recovery && recovery.trim() !== '') {
                    // Check if recovery text contains race-specific patterns (not just a plain number)
                    const containsRaceText = racePatterns.some(pattern => pattern.test(recovery));
                    const isJustNumber = /^\d+(\.\d+)?$/.test(recovery.trim()); // Just a plain number
                    
                    if (containsRaceText && !isJustNumber) {
                        isRaceResult = true;
                    }
                }
                
                // Debug logging for specific horses/dates mentioned by user
                if ((horseName && (horseName.toLowerCase().includes('just inspiration') || horseName.toLowerCase().includes('rock of rosha'))) ||
                    (dateValue && (dateValue.includes('8/2') || dateValue.includes('8/25') || dateValue.includes('02/08') || dateValue.includes('25/08')))) {
                    console.log(`Race detection for ${horseName} on ${dateValue}:`);
                    console.log(`  - Recovery text: "${recovery}"`);
                    console.log(`  - Has dateHyperlink: ${!!dateHyperlink}`);
                    console.log(`  - Has horseHyperlink: ${!!horseHyperlink}`);
                    console.log(`  - Contains race patterns: ${recovery ? racePatterns.some(pattern => pattern.test(recovery)) : false}`);
                    console.log(`  - Is just number: ${recovery ? /^\d+(\.\d+)?$/.test(recovery.trim()) : false}`);
                    console.log(`  - Detected as race: ${isRaceResult}`);
                }
                
                if (!isRaceResult && distance > 0) {
                    // Primary: Distance-based detection (gallops are basically always over 1600m)
                    if (distance >= 1600) {
                        // Check if it's a slow workout that should be excluded
                        const best200m = rowData['meilleurs 200m'] || rowData['best 200m'] || rowData['best 1f'] || '';
                        const best1000m = rowData['meilleurs 1000m'] || rowData['best 1000m'] || rowData['best 5f'] || '';
                        
                        let isSlowWorkout = false;
                        
                        // Check if fastest 200m is over 15 seconds
                        if (best200m && best200m !== 'N/C' && best200m !== '-') {
                            const time200m = parseTimeToSeconds(best200m);
                            if (time200m && time200m > 15) {
                                isSlowWorkout = true;
                            }
                        }
                        
                        // Check if 5F (1000m) time is over 1:45 (105 seconds)
                        if (!isSlowWorkout && best1000m && best1000m !== 'N/C' && best1000m !== '-') {
                            const time1000m = parseTimeToSeconds(best1000m);
                            if (time1000m && time1000m > 105) {
                                isSlowWorkout = true;
                            }
                        }
                        
                        // Only mark as workout if it's not a slow workout
                        if (!isSlowWorkout) {
                            isWorkout = true;
                        }
                    }
                }

                const detailRow = {
                    date: dateValue,
                    rawDate: rawDateObject, // Keep original Date object for calculations
                    cheval: horseName,
                    age: rowData.age || rowData['√¢ge'] || '',
                    distance: rowData['distance du travail'] || rowData['distance'] || '',
                    maxSpeed: rowData['vitesse maximale'] || rowData['max speed'] || '',
                    avgSpeed: rowData['vitesse moyenne du travail'] || rowData['avg speed'] || '',
                    best200m: rowData['meilleurs 200m'] || rowData['best 200m'] || rowData['best 1f'] || '',
                    best800m: rowData['meilleurs 800m'] || rowData['best 800m'] || rowData['best 4f'] || '',
                    best1000m: rowData['meilleurs 1000m'] || rowData['best 1000m'] || rowData['best 5f'] || '',
                    maxHeartRate: rowData['fr√©quence cardiaque maximale atteinte durant l\'entra√Ænement'] || rowData['max heart rate'] || '',
                    recovery: rowData['r√©cup√©ration apr√®s l\'effort'] || rowData['fast recovery'] || '',
                    recovery15min: rowData['fr√©quence cardiaque apr√®s 15 minutes de r√©cup√©ration'] || rowData['15 recovery'] || '',
                    heartRateReturn: rowData['fr√©quence cardiaque au retour'] || rowData['heart rate return'] || '',
                    amplitude35: rowData['amplitude √† 35 km/h'] || rowData['amplitude 35'] || '',
                    effort1: rowData['temps zone effort 1'] || rowData['effort zone 1'] || '',
                    effort2: rowData['temps zone effort 2'] || rowData['effort zone 2'] || '',
                    effort3: rowData['temps zone effort 3'] || rowData['effort zone 3'] || '',
                    effort4: rowData['temps zone effort 4'] || rowData['effort zone 4'] || '',
                    effort5: rowData['temps zone effort 5'] || rowData['effort zone 5'] || '',
                    isBoldRed: isWorkout,
                    isRaceResult: isRaceResult,
                    dateHyperlink: dateHyperlink,
                    horseHyperlink: horseHyperlink
                };
                
                if (detailRow.date || detailRow.distance || detailRow.maxSpeed || detailRow.best200m || detailRow.best1000m) {
                    detailData.push(detailRow);
                    
                    // Collect gallop and race dates, plus race valeurs
                    if (detailRow.rawDate) {
                        const rowDate = detailRow.rawDate;
                        const currentDate = new Date();
                        currentDate.setHours(23, 59, 59, 999); // Set to end of today to include today's events

                        if (isWorkout) {
                            gallopDates.push(rowDate);
                        } else if (isRaceResult && rowDate <= currentDate) {
                            // Only include races that have already happened (not future races)
                            raceDates.push(rowDate);

                            // Extract Valeur from race row's max heart rate (should be under 60)
                            const maxHeartRate = parseFloat(detailRow.maxHeartRate);
                            if (maxHeartRate && maxHeartRate < 60) {
                                raceValeurs.push({
                                    date: rowDate,
                                    valeur: maxHeartRate
                                });
                            }
                        }
                    }
                }
                
                // Get age
                if (!age) {
                    const ageValue = rowData.age || rowData['√¢ge'];
                    if (ageValue) {
                        const parsedAge = parseInt(ageValue);
                        if (!isNaN(parsedAge)) {
                            age = parsedAge;
                        }
                    }
                }
                
                // Exclude race results from main page calculations (but still collect race dates)
                if (!isRaceResult) {
                    // Check for 1F times
                    const oneF = rowData['best 1f'] || rowData['meilleurs 200m'] || rowData['1f'] || rowData['1 f'] || rowData['1furlong'];
                    if (oneF && isValidTime(oneF)) {
                        const fastRecoveryValue = rowData['r√©cup√©ration apr√®s l\'effort'] || rowData['fast recovery'] || '';
                        const recovery15Value = rowData['fr√©quence cardiaque apr√®s 15 minutes de r√©cup√©ration'] || rowData['15 recovery'] || '';
                        const fiveF = rowData['best 5f'] || rowData['meilleurs 1000m'] || rowData['5f'] || rowData['5 f'] || rowData['5furlong'];
                        
                        const fastRecoveryColor = getFastRecoveryColor(fastRecoveryValue);
                        const recovery15Color = getRecovery15Color(recovery15Value);
                        
                        times1f.push({ 
                            time: oneF, 
                            seconds: timeToSeconds(oneF),
                            date: dateValue.toString(),
                            fastRecovery: fastRecoveryValue,
                            recovery15min: recovery15Value,
                            fastRecoveryColor: fastRecoveryColor,
                            recovery15Color: recovery15Color,
                            corresponding5f: fiveF,
                            maxSpeed: maxSpeed || null
                        });
                    }
                    
                    // Check for 5F times
                    const fiveF = rowData['best 5f'] || rowData['meilleurs 1000m'] || rowData['5f'] || rowData['5 f'] || rowData['5furlong'];
                    if (fiveF && isValidTime(fiveF)) {
                        const fastRecoveryValue = rowData['r√©cup√©ration apr√®s l\'effort'] || rowData['fast recovery'] || '';
                        const recovery15Value = rowData['fr√©quence cardiaque apr√®s 15 minutes de r√©cup√©ration'] || rowData['15 recovery'] || '';
                        
                        const fastRecoveryColor = getFastRecoveryColor(fastRecoveryValue);
                        const recovery15Color = getRecovery15Color(recovery15Value);
                        
                        // Get corresponding 1F time from the same session
                        const oneF = rowData['best 1f'] || rowData['meilleurs 200m'] || rowData['1f'] || rowData['1 f'] || rowData['200m'];
                        
                        times5f.push({ 
                            time: fiveF, 
                            seconds: timeToSeconds(fiveF),
                            date: dateValue.toString(),
                            fastRecovery: fastRecoveryValue,
                            recovery15min: recovery15Value,
                            fastRecoveryColor: fastRecoveryColor,
                            recovery15Color: recovery15Color,
                            maxSpeed: maxSpeed || null,
                            corresponding1f: oneF
                        });
                    }
                    
                    // Check for speed
                    const speedColumns = ['max speed', 'vitesse maximale', 'avg speed', 'speed', 'maximum speed', 'top speed', 'mph', 'max mph'];
                    for (const col of speedColumns) {
                        if (rowData[col]) {
                            const speed = parseFloat(rowData[col]);
                            if (!isNaN(speed)) {
                                speeds.push(speed);
                                
                                // For max speeds, also collect corresponding training data
                                const oneF = rowData['best 1f'] || rowData['meilleurs 200m'] || rowData['1f'] || rowData['1 f'] || rowData['200m'];
                                const fiveF = rowData['best 5f'] || rowData['meilleurs 1000m'] || rowData['5f'] || rowData['5 f'] || rowData['5furlong'];
                                
                                // Get recovery values from current row
                                const currentFastRecovery = (rowData['r√©cup√©ration apr√®s l\'effort'] || rowData['fast recovery'] || '').toString().toLowerCase();
                                const currentRecovery15 = (rowData['fr√©quence cardiaque apr√®s 15 minutes de r√©cup√©ration'] || rowData['15 recovery'] || '').toString();
                                
                                const fastRecoveryColor = getFastRecoveryColor(currentFastRecovery);
                                const recovery15Color = getRecovery15Color(currentRecovery15);
                                
                                maxSpeeds.push({ 
                                    speed: speed,
                                    date: dateValue.toString(),
                                    fastRecovery: currentFastRecovery,
                                    recovery15min: currentRecovery15,
                                    fastRecoveryColor: fastRecoveryColor,
                                    recovery15Color: recovery15Color,
                                    corresponding1f: oneF,
                                    corresponding5f: fiveF
                                });
                            }
                        }
                    }
                }
            }
            
            if (times1f.length > 0) {
                const fastest1f = times1f.reduce((min, current) => 
                    current.seconds < min.seconds ? current : min
                );
                best1f = fastest1f.time;
                dateOfBest1f = fastest1f.date;
                best1fRecovery = fastest1f.fastRecovery;
                best1fRecovery15min = fastest1f.recovery15min;
                best1fRecoveryColor = fastest1f.fastRecoveryColor;
                best1fRecovery15Color = fastest1f.recovery15Color;
                best1fCorresponding5f = fastest1f.corresponding5f;
                best1fMaxSpeed = fastest1f.maxSpeed;
            }
            
            if (times5f.length > 0) {
                const fastest5f = times5f.reduce((min, current) => 
                    current.seconds < min.seconds ? current : min
                );
                best5f = fastest5f.time;
                dateOfBest5f = fastest5f.date;
                fastRecovery = fastest5f.fastRecovery;
                recovery15min = fastest5f.recovery15min;
                fastRecoveryColor = fastest5f.fastRecoveryColor;
                recovery15Color = fastest5f.recovery15Color;
                best5fMaxSpeed = fastest5f.maxSpeed;
                best5fCorresponding1f = fastest5f.corresponding1f;
            }
            
            if (speeds.length > 0) {
                maxSpeed = Math.max(...speeds);
            }
            
            if (maxSpeeds.length > 0) {
                const fastestMaxSpeed = maxSpeeds.reduce((max, current) => 
                    current.speed > max.speed ? current : max
                );
                dateOfMaxSpeed = fastestMaxSpeed.date;
                maxSpeedRecovery = fastestMaxSpeed.fastRecovery;
                maxSpeedRecovery15min = fastestMaxSpeed.recovery15min;
                maxSpeedRecoveryColor = fastestMaxSpeed.fastRecoveryColor;
                maxSpeedRecovery15Color = fastestMaxSpeed.recovery15Color;
                maxSpeedCorresponding1f = fastestMaxSpeed.corresponding1f;
                maxSpeedCorresponding5f = fastestMaxSpeed.corresponding5f;
            }
            
            allHorseDetailData[horseName] = detailData;
            
            // Find most recent gallop and race dates, plus most recent valeur
            let lastGallop = null;
            let lastRace = null;
            let valeur = null;
            
            if (gallopDates.length > 0) {
                const mostRecentGallop = new Date(Math.max(...gallopDates));
                lastGallop = formatDateEuropean(mostRecentGallop);
            }

            if (raceDates.length > 0) {
                const mostRecentRace = new Date(Math.max(...raceDates));
                lastRace = formatDateEuropean(mostRecentRace);
            }
            
            // Find most recent Valeur from races
            if (raceValeurs.length > 0) {
                const mostRecentValeur = raceValeurs.reduce((latest, current) => {
                    return current.date > latest.date ? current : latest;
                });
                valeur = mostRecentValeur.valeur;
            }
            
            return {
                name: horseName,
                lastGallop: lastGallop,
                lastRace: lastRace,
                valeur: valeur,
                age: age,
                group: getHorseGroup(horseName),
                best1f: best1f,
                best5f: best5f,
                dateOfBest5f: dateOfBest5f,
                dateOfBest1f: dateOfBest1f,
                best1fRecovery: best1fRecovery,
                best1fRecovery15min: best1fRecovery15min,
                best1fRecoveryColor: best1fRecoveryColor,
                best1fRecovery15Color: best1fRecovery15Color,
                best1fCorresponding5f: best1fCorresponding5f,
                fastRecovery: fastRecovery,
                recovery15min: recovery15min,
                fastRecoveryColor: fastRecoveryColor,
                recovery15Color: recovery15Color,
                maxSpeed: maxSpeed,
                best1fMaxSpeed: best1fMaxSpeed,
                best5fMaxSpeed: best5fMaxSpeed,
                best5fCorresponding1f: best5fCorresponding1f,
                dateOfMaxSpeed: dateOfMaxSpeed,
                maxSpeedRecovery: maxSpeedRecovery,
                maxSpeedRecovery15min: maxSpeedRecovery15min,
                maxSpeedRecoveryColor: maxSpeedRecoveryColor,
                maxSpeedRecovery15Color: maxSpeedRecovery15Color,
                maxSpeedCorresponding1f: maxSpeedCorresponding1f,
                maxSpeedCorresponding5f: maxSpeedCorresponding5f
            };
        }

        function isValidTime(timeStr) {
            if (!timeStr) return false;
            const str = timeStr.toString().trim();
            if (str === 'N/A' || str === '' || str === 'NaN') return false;
            return /^\d{1,2}:\d{2}\.\d{2}$/.test(str);
        }

        function timeToSeconds(timeStr) {
            const parts = timeStr.toString().trim().split(':');
            const minutes = parseInt(parts[0]);
            const secondsParts = parts[1].split('.');
            const seconds = parseInt(secondsParts[0]);
            const hundredths = parseInt(secondsParts[1]);

            const result = minutes * 60 + seconds + hundredths / 100;

            // Debug specific cases for time conversion issues
            if (timeStr === "1:00.04" || timeStr === "01:00.04" || timeStr.includes("1:00.04")) {
                console.log(`timeToSeconds debug for "${timeStr}":`);
                console.log(`  - parts: [${parts.join(', ')}]`);
                console.log(`  - minutes: ${minutes}`);
                console.log(`  - secondsParts: [${secondsParts.join(', ')}]`);
                console.log(`  - seconds: ${seconds}`);
                console.log(`  - hundredths: ${hundredths}`);
                console.log(`  - calculation: ${minutes} * 60 + ${seconds} + ${hundredths} / 100`);
                console.log(`  - result: ${result}`);
                console.log(`  - Expected result: 60.04`);
            }

            return result;
        }

        function parseTimeToSeconds(timeStr) {
            if (!timeStr || timeStr === 'N/C' || timeStr === '-' || timeStr === 'N/A') return null;
            
            const str = timeStr.toString().trim();
            
            // Handle MM:SS.HH format (e.g., "01:23.45")
            if (/^\d{2}:\d{2}\.\d{2}$/.test(str)) {
                return timeToSeconds(str);
            }
            
            // Handle SS.HH format (e.g., "15.23" for seconds)
            if (/^\d{1,2}\.\d{2}$/.test(str)) {
                const parts = str.split('.');
                return parseInt(parts[0]) + parseInt(parts[1]) / 100;
            }
            
            // Handle plain seconds (e.g., "15")
            if (/^\d{1,2}$/.test(str)) {
                return parseInt(str);
            }
            
            return null;
        }

        function parseRecoveryValues(recoveryStr) {
            if (!recoveryStr || recoveryStr === 'N/C' || recoveryStr === '-' || recoveryStr === 'N/A') {
                return { fastRecovery: null, recovery15min: null };
            }
            
            const str = recoveryStr.toString().trim();
            
            // Handle "150/120" format (fast recovery / 15-min recovery)
            if (str.includes('/')) {
                const parts = str.split('/');
                const fastRecovery = parseInt(parts[0]);
                const recovery15min = parseInt(parts[1]);
                return {
                    fastRecovery: isNaN(fastRecovery) ? null : fastRecovery,
                    recovery15min: isNaN(recovery15min) ? null : recovery15min
                };
            }
            
            // Handle single number - assume it's fast recovery if no other context
            const singleValue = parseInt(str);
            if (!isNaN(singleValue)) {
                return {
                    fastRecovery: singleValue,
                    recovery15min: null
                };
            }
            
            return { fastRecovery: null, recovery15min: null };
        }

        function processWorstRecoveriesData(viewType) {
            const worstRecoveries = [];
            
            if (!currentWorkbook) {
                console.error('No workbook data available');
                return worstRecoveries;
            }
            
            filteredData.forEach(horse => {
                let worstSession = null;
                let worstValue = -1;
                
                // Get all training data for this horse
                const worksheet = currentWorkbook.Sheets[horse.name];
                if (!worksheet) {
                    return;
                }
                
                const range = XLSX.utils.decode_range(worksheet['!ref']);
                
                for (let i = 1; i <= range.e.r; i++) {
                    const rowData = {};
                    for (let j = 0; j <= range.e.c; j++) {
                        const cell = worksheet[XLSX.utils.encode_cell({r: i, c: j})];
                        if (cell) {
                            const headerCell = worksheet[XLSX.utils.encode_cell({r: 0, c: j})];
                            if (headerCell && headerCell.v) {
                                const header = headerCell.v.toString().toLowerCase();
                                rowData[header] = cell.v;
                            }
                        }
                    }
                    
                    // Skip if no meaningful data
                    if (!rowData['date'] && !rowData['r√©cup√©ration apr√®s l\'effort'] && !rowData['fr√©quence cardiaque apr√®s 15 minutes de r√©cup√©ration']) {
                        continue;
                    }
                    
                    // Parse recovery values
                    const fastRecoveryStr = rowData['r√©cup√©ration apr√®s l\'effort'] || rowData['fast recovery'] || '';
                    const recovery15minStr = rowData['fr√©quence cardiaque apr√®s 15 minutes de r√©cup√©ration'] || rowData['15 recovery'] || '';
                    
                    
                    const fastRecoveryParsed = parseRecoveryValues(fastRecoveryStr);
                    const recovery15minParsed = parseRecoveryValues(recovery15minStr);
                    
                    // Check which recovery value to compare based on view type
                    let currentValue = -1;
                    if (viewType === 'worstFastRecovery') {
                        if (fastRecoveryParsed.fastRecovery !== null) {
                            currentValue = fastRecoveryParsed.fastRecovery;
                        }
                    } else if (viewType === 'worst15minRecovery') {
                        if (recovery15minParsed.recovery15min !== null || recovery15minParsed.fastRecovery !== null) {
                            // For 15-min recovery, check both fields (some might be in recovery15min, others in fastRecovery)
                            const recovery15Value = parseFloat(recovery15minStr) || parseFloat(fastRecoveryStr) || -1;
                            if (!isNaN(recovery15Value)) {
                                currentValue = recovery15Value;
                            }
                        }
                    }
                    
                    
                    // Handle ties by preferring most recent date
                    const sessionDate = rowData['date'] instanceof Date ? rowData['date'] : parseEuropeanDate(rowData['date']);
                    const shouldUpdate = currentValue > worstValue || 
                                       (currentValue === worstValue && worstSession && sessionDate > new Date(worstSession.rawDate));
                    
                    if (shouldUpdate) {
                        worstValue = currentValue;
                        worstSession = {
                            horseName: horse.name,
                            // Add essential horse information from main horse data
                            age: horse.age,
                            group: horse.group,
                            lastGallop: horse.lastGallop,
                            lastRace: horse.lastRace,
                            valeur: horse.valeur,
                            date: rowData['date'] ? formatDateEuropean(rowData['date']) : '-',
                            rawDate: rowData['date'], // Keep raw date for comparison
                            distance: rowData['distance du travail'] || rowData['distance'] || '-',
                            maxSpeed: rowData['vitesse maximale'] || rowData['max speed'] || '-',
                            best1f: rowData['meilleurs 200m'] || rowData['best 200m'] || rowData['best 1f'] || '-',
                            best5f: rowData['meilleurs 1000m'] || rowData['best 1000m'] || rowData['best 5f'] || '-',
                            maxHeartRate: rowData['fr√©quence cardiaque maximale atteinte durant l\'entra√Ænement'] || rowData['max heart rate'] || '-',
                            // Store both recovery values from the same session
                            fastRecoveryValue: fastRecoveryParsed.fastRecovery || parseFloat(fastRecoveryStr) || null,
                            recovery15minValue: recovery15minParsed.recovery15min || recovery15minParsed.fastRecovery || parseFloat(recovery15minStr) || null,
                            fastRecoveryStr: fastRecoveryStr || '-',
                            recovery15minStr: recovery15minStr || '-',
                            recoveryValue: currentValue,
                            recoveryType: viewType === 'worstFastRecovery' ? 'Fast Recovery' : '15 Min Recovery'
                        };
                    }
                }
                
                if (worstSession) {
                    worstRecoveries.push(worstSession);
                }
            });
            
            return worstRecoveries;
        }

        function changeView() {
            const viewFilter = document.getElementById('viewFilter');
            const selectedView = viewFilter.value;
            
            // Update table headers based on selected view
            updateTableHeaders(selectedView);
            
            // Update data display
            displayData();
        }

        function updateTableHeaders(viewType) {
            const thead = document.querySelector('#horseTable thead tr');
            
            // Set headers and sort keys based on view type
            let dateColumnHeader, oneF_Header, fiveF_Header, dateSortKey, fastRecoverySortKey, recovery15SortKey;
            
            if (viewType === 'best1f') {
                dateColumnHeader = 'Date of Best 1F';
                oneF_Header = 'Best 1F';
                fiveF_Header = '5F Time';
                dateSortKey = 'dateOfBest1f';
                fastRecoverySortKey = 'best1fRecovery';
                recovery15SortKey = 'best1fRecovery15min';
            } else if (viewType === 'maxSpeed') {
                dateColumnHeader = 'Date of Max';
                oneF_Header = 'Time 1F';
                fiveF_Header = 'Time 5F';
                dateSortKey = 'dateOfMaxSpeed';
                fastRecoverySortKey = 'maxSpeedRecovery';
                recovery15SortKey = 'maxSpeedRecovery15min';
            } else if (viewType === 'worstFastRecovery' || viewType === 'worst15minRecovery') {
                dateColumnHeader = 'Date of Training';
                oneF_Header = '1F Time';
                fiveF_Header = '5F Time';
                dateSortKey = 'dateOfBest5f'; // For recovery views, use session date
                fastRecoverySortKey = 'fastRecovery';
                recovery15SortKey = 'recovery15min';
            } else { // best5f view
                dateColumnHeader = 'Date of Best 5F';
                oneF_Header = 'Time 1F';
                fiveF_Header = 'Best 5F';
                dateSortKey = 'dateOfBest5f';
                fastRecoverySortKey = 'fastRecovery';
                recovery15SortKey = 'recovery15min';
            }
            
            thead.innerHTML = `
                <th onclick="sortTable('name')" class="horse-name-col">Horse <span class="sort-indicator">‚Üï</span></th>
                <th onclick="sortTable('age')">Age <span class="sort-indicator">‚Üï</span></th>
                <th onclick="sortTable('group')">Group <span class="sort-indicator">‚Üï</span></th>
                <th onclick="sortTable('lastGallop')" class="date-col">Last Gallop <span class="sort-indicator">‚Üï</span></th>
                <th onclick="sortTable('lastRace')" class="date-col">Last Race <span class="sort-indicator">‚Üï</span></th>
                <th onclick="sortTable('valeur')" class="date-col">Valeur <span class="sort-indicator">‚Üï</span></th>
                <th onclick="sortTable('${dateSortKey}')" class="date-col">${dateColumnHeader} <span class="sort-indicator">‚Üï</span></th>
                <th onclick="sortTable('${viewType === 'best1f' ? 'best1f' : viewType === 'maxSpeed' ? 'maxSpeedCorresponding1f' : viewType === 'best5f' ? 'best5fCorresponding1f' : 'best1f'}')">${oneF_Header} <span class="sort-indicator">‚Üï</span></th>
                <th onclick="sortTable('${viewType === 'best1f' ? 'best1fCorresponding5f' : viewType === 'maxSpeed' ? 'maxSpeedCorresponding5f' : 'best5f'}')">${fiveF_Header} <span class="sort-indicator">‚Üï</span></th>
                <th onclick="sortTable('${fastRecoverySortKey}')" class="fast-recovery-col">Fast <span class="sort-indicator">‚Üï</span></th>
                <th onclick="sortTable('${recovery15SortKey}')">15 min <span class="sort-indicator">‚Üï</span></th>
                <th onclick="sortTable('maxSpeed')" class="max-speed-col">Max Speed <span class="sort-indicator">‚Üï</span></th>
            `;
        }

        function updateHorseFilter() {
            const horseList = document.getElementById('horseList');
            const horses = horseData.map(horse => horse.name).sort();
            
            horseList.innerHTML = '';
            horses.forEach(horseName => {
                const option = document.createElement('option');
                option.value = horseName;
                horseList.appendChild(option);
            });
        }

        function updateAgeFilter() {
            const ageFilter = document.getElementById('ageFilter');
            const ages = [...new Set(horseData.map(horse => horse.age).filter(age => age !== null))].sort((a, b) => a - b);
            
            ageFilter.innerHTML = '<option value="">All Ages</option>';
            ages.forEach(age => {
                const option = document.createElement('option');
                option.value = age;
                option.textContent = age;
                ageFilter.appendChild(option);
            });
        }

        function filterData() {
            const horseFilter = document.getElementById('horseFilter').value.toLowerCase().trim();
            const ageFilter = document.getElementById('ageFilter').value;
            
            filteredData = horseData.filter(horse => {
                if (horseFilter && !horse.name.toLowerCase().includes(horseFilter)) {
                    return false;
                }
                if (ageFilter && horse.age !== parseInt(ageFilter)) {
                    return false;
                }
                return true;
            });
            
            sortData();
        }


        function sortTable(column) {
            if (currentSort.column === column) {
                currentSort.order = currentSort.order === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.column = column;
                currentSort.order = 'asc';
            }
            
            sortData();
        }

        function sortData() {
            const viewFilter = document.getElementById('viewFilter');
            const selectedView = viewFilter.value;
            
            if (selectedView === 'best5f') {
                // Sort the original filtered data for Best 5F Time view
                filteredData.sort((a, b) => {
                    let aVal = a[currentSort.column];
                    let bVal = b[currentSort.column];
                    
                    if (currentSort.column === 'best1f' || currentSort.column === 'best5f' || currentSort.column === 'best5fCorresponding1f') {
                        aVal = aVal ? timeToSeconds(aVal) : Infinity;
                        bVal = bVal ? timeToSeconds(bVal) : Infinity;
                    } else if (currentSort.column === 'age' || currentSort.column === 'maxSpeed' || currentSort.column === 'fastRecovery' || currentSort.column === 'recovery15min') {
                        aVal = parseFloat(aVal) || 0;
                        bVal = parseFloat(bVal) || 0;
                    } else if (currentSort.column === 'lastGallop' || currentSort.column === 'lastRace' || currentSort.column === 'dateOfBest5f') {
                        aVal = aVal ? parseEuropeanDate(aVal) : new Date(0);
                        bVal = bVal ? parseEuropeanDate(bVal) : new Date(0);
                    } else if (currentSort.column === 'valeur') {
                        aVal = parseFloat(aVal) || 0;
                        bVal = parseFloat(bVal) || 0;
                    } else if (currentSort.column === 'group') {
                        // Custom sorting for group: A < B < C, with '-' last
                        const getGroupSortValue = (group) => {
                            if (group === '-') return 999;
                            if (group === 'A') return 1;
                            if (group === 'B') return 2;
                            if (group === 'C') return 3;
                            if (group.includes('/')) {
                                // For combined groups like A/B, use the first letter
                                return getGroupSortValue(group.charAt(0));
                            }
                            return 500;
                        };
                        aVal = getGroupSortValue(aVal);
                        bVal = getGroupSortValue(bVal);
                    } else {
                        aVal = aVal || '';
                        bVal = bVal || '';
                    }
                    
                    if (currentSort.order === 'asc') {
                        return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                    } else {
                        return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
                    }
                });
            } else if (selectedView === 'best1f') {
                // Sort the original filtered data for Best 1F Time view
                filteredData.sort((a, b) => {
                    let aVal = a[currentSort.column];
                    let bVal = b[currentSort.column];
                    
                    if (currentSort.column === 'best1f' || currentSort.column === 'best1fCorresponding5f') {
                        aVal = aVal ? timeToSeconds(aVal) : Infinity;
                        bVal = bVal ? timeToSeconds(bVal) : Infinity;
                    } else if (currentSort.column === 'age' || currentSort.column === 'maxSpeed' || currentSort.column === 'best1fRecovery' || currentSort.column === 'best1fRecovery15min') {
                        aVal = parseFloat(aVal) || 0;
                        bVal = parseFloat(bVal) || 0;
                    } else if (currentSort.column === 'lastGallop' || currentSort.column === 'lastRace' || currentSort.column === 'dateOfBest1f') {
                        aVal = aVal ? parseEuropeanDate(aVal) : new Date(0);
                        bVal = bVal ? parseEuropeanDate(bVal) : new Date(0);
                    } else if (currentSort.column === 'valeur') {
                        aVal = parseFloat(aVal) || 0;
                        bVal = parseFloat(bVal) || 0;
                    } else if (currentSort.column === 'group') {
                        // Custom sorting for group: A < B < C, with '-' last
                        const getGroupSortValue = (group) => {
                            if (group === '-') return 999;
                            if (group === 'A') return 1;
                            if (group === 'B') return 2;
                            if (group === 'C') return 3;
                            if (group.includes('/')) {
                                // For combined groups like A/B, use the first letter
                                return getGroupSortValue(group.charAt(0));
                            }
                            return 500;
                        };
                        aVal = getGroupSortValue(aVal);
                        bVal = getGroupSortValue(bVal);
                    } else {
                        aVal = aVal || '';
                        bVal = bVal || '';
                    }
                    
                    if (currentSort.order === 'asc') {
                        return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                    } else {
                        return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
                    }
                });
            } else if (selectedView === 'maxSpeed') {
                // Sort the original filtered data for Max Speed view
                filteredData.sort((a, b) => {
                    let aVal = a[currentSort.column];
                    let bVal = b[currentSort.column];
                    
                    if (currentSort.column === 'maxSpeedCorresponding1f' || currentSort.column === 'maxSpeedCorresponding5f') {
                        aVal = aVal ? timeToSeconds(aVal) : Infinity;
                        bVal = bVal ? timeToSeconds(bVal) : Infinity;
                    } else if (currentSort.column === 'age' || currentSort.column === 'maxSpeed' || currentSort.column === 'maxSpeedRecovery' || currentSort.column === 'maxSpeedRecovery15min') {
                        aVal = parseFloat(aVal) || 0;
                        bVal = parseFloat(bVal) || 0;
                    } else if (currentSort.column === 'lastGallop' || currentSort.column === 'lastRace' || currentSort.column === 'dateOfMaxSpeed') {
                        aVal = aVal ? parseEuropeanDate(aVal) : new Date(0);
                        bVal = bVal ? parseEuropeanDate(bVal) : new Date(0);
                    } else if (currentSort.column === 'valeur') {
                        aVal = parseFloat(aVal) || 0;
                        bVal = parseFloat(bVal) || 0;
                    } else if (currentSort.column === 'group') {
                        // Custom sorting for group: A < B < C, with '-' last
                        const getGroupSortValue = (group) => {
                            if (group === '-') return 999;
                            if (group === 'A') return 1;
                            if (group === 'B') return 2;
                            if (group === 'C') return 3;
                            if (group.includes('/')) {
                                // For combined groups like A/B, use the first letter
                                return getGroupSortValue(group.charAt(0));
                            }
                            return 500;
                        };
                        aVal = getGroupSortValue(aVal);
                        bVal = getGroupSortValue(bVal);
                    } else {
                        aVal = aVal || '';
                        bVal = bVal || '';
                    }
                    
                    if (currentSort.order === 'asc') {
                        return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                    } else {
                        return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
                    }
                });
            } else {
                // For recovery views, we need to sort differently since displayData() 
                // will process the recovery data. The sorting will be handled in displayData()
                // by sorting the recovery session data
            }
            
            displayData();
        }

        function displayData() {
            const tbody = document.getElementById('horseTableBody');
            const viewFilter = document.getElementById('viewFilter');
            const selectedView = viewFilter.value;
            
            let dataToDisplay = [];
            
            if (selectedView === 'best5f') {
                // Use existing filteredData for Best 5F Time view
                dataToDisplay = filteredData;
                
                if (dataToDisplay.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="12" class="no-data">No horses match the current filters.</td></tr>';
                    return;
                }
                
                tbody.innerHTML = dataToDisplay.map(horse => {
                    const fastRecoveryStyle = horse.fastRecoveryColor ? `style="background-color: ${horse.fastRecoveryColor}; color: #000;"` : '';
                    const recovery15Style = horse.recovery15Color ? `style="background-color: ${horse.recovery15Color}; color: #000;"` : '';
                    
                    return `
                        <tr class="clickable-row" onclick="showHorseDetail('${horse.name}')">
                            <td class="horse-name-cell"><span style="${getHorseNameColor(horse.name)} font-weight: bold; padding: 2px 6px; border-radius: 3px;">${horse.name}</span></td>
                            <td class="age-cell">${cleanNCValue(horse.age)}</td>
                            <td class="group-cell" style="text-align: center; font-weight: bold;">${horse.group}</td>
                            <td class="date-col">${cleanNCValue(horse.lastGallop)}</td>
                            <td class="date-col">${cleanNCValue(horse.lastRace)}</td>
                            <td class="date-col">${cleanNCValue(horse.valeur)}</td>
                            <td class="date-col">${cleanNCValue(horse.dateOfBest5f)}</td>
                            <td class="time-cell">${cleanNCValue(horse.best5fCorresponding1f)}</td>
                            <td class="time-cell">${cleanNCValue(horse.best5f)}</td>
                            <td class="recovery-cell fast-recovery-col" ${fastRecoveryStyle}>${cleanNCValue(horse.fastRecovery)}</td>
                            <td class="recovery15-cell" ${recovery15Style}>${cleanNCValue(horse.recovery15min)}</td>
                            <td class="speed-cell max-speed-col">${horse.best5fMaxSpeed && horse.best5fMaxSpeed !== 'N/C' && horse.best5fMaxSpeed !== 'n/c' ? horse.best5fMaxSpeed.toFixed(2) : '-'}</td>
                        </tr>
                    `;
                }).join('');
            } else if (selectedView === 'best1f') {
                // Use existing filteredData but display Best 1F Time data
                dataToDisplay = filteredData;
                
                if (dataToDisplay.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="12" class="no-data">No horses match the current filters.</td></tr>';
                    return;
                }
                
                tbody.innerHTML = dataToDisplay.map(horse => {
                    const fastRecoveryStyle = horse.best1fRecoveryColor ? `style="background-color: ${horse.best1fRecoveryColor}; color: #000;"` : '';
                    const recovery15Style = horse.best1fRecovery15Color ? `style="background-color: ${horse.best1fRecovery15Color}; color: #000;"` : '';
                    
                    return `
                        <tr class="clickable-row" onclick="showHorseDetail('${horse.name}')">
                            <td class="horse-name-cell"><span style="${getHorseNameColor(horse.name)} font-weight: bold; padding: 2px 6px; border-radius: 3px;">${horse.name}</span></td>
                            <td class="age-cell">${cleanNCValue(horse.age)}</td>
                            <td class="group-cell" style="text-align: center; font-weight: bold;">${horse.group}</td>
                            <td class="date-col">${cleanNCValue(horse.lastGallop)}</td>
                            <td class="date-col">${cleanNCValue(horse.lastRace)}</td>
                            <td class="date-col">${cleanNCValue(horse.valeur)}</td>
                            <td class="date-col">${cleanNCValue(horse.dateOfBest1f)}</td>
                            <td class="time-cell">${cleanNCValue(horse.best1f)}</td>
                            <td class="time-cell">${cleanNCValue(horse.best1fCorresponding5f)}</td>
                            <td class="recovery-cell fast-recovery-col" ${fastRecoveryStyle}>${cleanNCValue(horse.best1fRecovery)}</td>
                            <td class="recovery15-cell" ${recovery15Style}>${cleanNCValue(horse.best1fRecovery15min)}</td>
                            <td class="speed-cell max-speed-col">${horse.best1fMaxSpeed && horse.best1fMaxSpeed !== 'N/C' && horse.best1fMaxSpeed !== 'n/c' ? horse.best1fMaxSpeed.toFixed(2) : '-'}</td>
                        </tr>
                    `;
                }).join('');
            } else if (selectedView === 'maxSpeed') {
                // Use existing filteredData but display Max Speed data
                dataToDisplay = filteredData;
                
                if (dataToDisplay.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="12" class="no-data">No horses match the current filters.</td></tr>';
                    return;
                }
                
                tbody.innerHTML = dataToDisplay.map(horse => {
                    const fastRecoveryStyle = horse.maxSpeedRecoveryColor ? `style="background-color: ${horse.maxSpeedRecoveryColor}; color: #000;"` : '';
                    const recovery15Style = horse.maxSpeedRecovery15Color ? `style="background-color: ${horse.maxSpeedRecovery15Color}; color: #000;"` : '';
                    
                    return `
                        <tr class="clickable-row" onclick="showHorseDetail('${horse.name}')">
                            <td class="horse-name-cell"><span style="${getHorseNameColor(horse.name)} font-weight: bold; padding: 2px 6px; border-radius: 3px;">${horse.name}</span></td>
                            <td class="age-cell">${cleanNCValue(horse.age)}</td>
                            <td class="group-cell" style="text-align: center; font-weight: bold;">${horse.group}</td>
                            <td class="date-col">${cleanNCValue(horse.lastGallop)}</td>
                            <td class="date-col">${cleanNCValue(horse.lastRace)}</td>
                            <td class="date-col">${cleanNCValue(horse.valeur)}</td>
                            <td class="date-col">${cleanNCValue(horse.dateOfMaxSpeed)}</td>
                            <td class="time-cell">${cleanNCValue(horse.maxSpeedCorresponding1f)}</td>
                            <td class="time-cell">${cleanNCValue(horse.maxSpeedCorresponding5f)}</td>
                            <td class="recovery-cell fast-recovery-col" ${fastRecoveryStyle}>${cleanNCValue(horse.maxSpeedRecovery)}</td>
                            <td class="recovery15-cell" ${recovery15Style}>${cleanNCValue(horse.maxSpeedRecovery15min)}</td>
                            <td class="speed-cell max-speed-col">${horse.maxSpeed && horse.maxSpeed !== 'N/C' && horse.maxSpeed !== 'n/c' ? horse.maxSpeed.toFixed(2) : '-'}</td>
                        </tr>
                    `;
                }).join('');
            } else {
                // Process worst recoveries data for the recovery views
                dataToDisplay = processWorstRecoveriesData(selectedView);
                
                if (dataToDisplay.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="12" class="no-data">No recovery data available.</td></tr>';
                    return;
                }
                
                // Sort the recovery data based on current sort settings
                dataToDisplay.sort((a, b) => {
                    let aVal, bVal;
                    
                    // Map the sort column to the recovery data structure
                    if (currentSort.column === 'name') {
                        aVal = a.horseName;
                        bVal = b.horseName;
                    } else if (currentSort.column === 'group') {
                        aVal = a.group || '-';
                        bVal = b.group || '-';
                        // Apply the same group sorting logic
                        const getGroupSortValue = (group) => {
                            if (group === '-') return 999;
                            if (group === 'A') return 1;
                            if (group === 'B') return 2;
                            if (group === 'C') return 3;
                            if (group.includes('/')) {
                                return getGroupSortValue(group.charAt(0));
                            }
                            return 500;
                        };
                        aVal = getGroupSortValue(aVal);
                        bVal = getGroupSortValue(bVal);
                    } else if (currentSort.column === 'lastGallop' || currentSort.column === 'lastRace' || currentSort.column === 'valeur' || currentSort.column === 'age') {
                        // These values are now directly available in the recovery session objects
                        aVal = a[currentSort.column] || '';
                        bVal = b[currentSort.column] || '';
                    } else if (currentSort.column === 'best1f') {
                        aVal = a.best1f;
                        bVal = b.best1f;
                    } else if (currentSort.column === 'best5f') {
                        aVal = a.best5f;
                        bVal = b.best5f;
                    } else if (currentSort.column === 'dateOfBest5f') {
                        aVal = a.date;
                        bVal = b.date;
                    } else if (currentSort.column === 'fastRecovery') {
                        aVal = a.fastRecoveryValue || 0;
                        bVal = b.fastRecoveryValue || 0;
                    } else if (currentSort.column === 'recovery15min') {
                        aVal = a.recovery15minValue || 0;
                        bVal = b.recovery15minValue || 0;
                    } else if (currentSort.column === 'maxSpeed') {
                        aVal = a.maxSpeed;
                        bVal = b.maxSpeed;
                    } else {
                        aVal = a[currentSort.column] || '';
                        bVal = b[currentSort.column] || '';
                    }
                    
                    // Parse values appropriately
                    if (currentSort.column === 'best1f' || currentSort.column === 'best5f') {
                        aVal = aVal ? timeToSeconds(aVal) : Infinity;
                        bVal = bVal ? timeToSeconds(bVal) : Infinity;
                    } else if (currentSort.column === 'age' || currentSort.column === 'maxSpeed' || currentSort.column === 'fastRecovery' || currentSort.column === 'recovery15min') {
                        aVal = parseFloat(aVal) || 0;
                        bVal = parseFloat(bVal) || 0;
                    } else if (currentSort.column === 'lastGallop' || currentSort.column === 'lastRace' || currentSort.column === 'dateOfBest5f') {
                        aVal = aVal ? parseEuropeanDate(aVal) : new Date(0);
                        bVal = bVal ? parseEuropeanDate(bVal) : new Date(0);
                    } else if (currentSort.column === 'valeur') {
                        aVal = parseFloat(aVal) || 0;
                        bVal = parseFloat(bVal) || 0;
                    }
                    
                    if (currentSort.order === 'asc') {
                        return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                    } else {
                        return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
                    }
                });
                
                tbody.innerHTML = dataToDisplay.map(session => {
                    // Use the same color coding functions as the original table
                    const fastRecoveryColor = getFastRecoveryColor(session.fastRecoveryValue);
                    const recovery15Color = getRecovery15Color(session.recovery15minValue);
                    
                    const fastRecoveryStyle = fastRecoveryColor ? `style="background-color: ${fastRecoveryColor}; color: #000;"` : '';
                    const recovery15Style = recovery15Color ? `style="background-color: ${recovery15Color}; color: #000;"` : '';
                    
                    // Show both recovery values from the same training session
                    const fastRecoveryDisplay = session.fastRecoveryValue ? session.fastRecoveryValue : '-';
                    const recovery15Display = session.recovery15minValue ? session.recovery15minValue : '-';
                    
                    return `
                        <tr class="clickable-row" onclick="showHorseDetail('${session.horseName}')">
                            <td class="horse-name-cell"><span style="${getHorseNameColor(session.horseName)} font-weight: bold; padding: 2px 6px; border-radius: 3px;">${session.horseName}</span></td>
                            <td class="age-cell">${cleanNCValue(session.age)}</td>
                            <td class="group-cell" style="text-align: center; font-weight: bold;">${session.group}</td>
                            <td class="date-col">${cleanNCValue(session.lastGallop)}</td>
                            <td class="date-col">${cleanNCValue(session.lastRace)}</td>
                            <td class="date-col">${cleanNCValue(session.valeur)}</td>
                            <td class="date-col">${cleanNCValue(session.date)}</td>
                            <td class="time-cell">${cleanNCValue(session.best1f)}</td>
                            <td class="time-cell">${cleanNCValue(session.best5f)}</td>
                            <td class="recovery-cell fast-recovery-col" ${fastRecoveryStyle}>${fastRecoveryDisplay}</td>
                            <td class="recovery15-cell" ${recovery15Style}>${recovery15Display}</td>
                            <td class="speed-cell max-speed-col">${cleanNCValue(session.maxSpeed)}</td>
                        </tr>
                    `;
                }).join('');
            }
        }

        // Helper function to format time values for Excel CSV export
        function formatTimeForExcel(value) {
            if (!value || value === '' || value === 'N/C') {
                return '';
            }
            // Check if value looks like a time format (contains colon or typical time patterns)
            if (typeof value === 'string' && (value.includes(':') || /^\d{2}:\d{2}/.test(value) || /^\d+\.\d+$/.test(value))) {
                return `="${value}"`; // Force Excel to treat as text
            }
            return value;
        }

        function exportToCsv() {
            if (filteredData.length === 0) {
                alert('No data to export');
                return;
            }

            const headers = ['Horse Name', 'Age', 'Group', 'Last Gallop', 'Last Race', 'Valeur', 'Date of Best 5F', 'Time 1F', 'Best 5F', 'Fast', '15 min Recovery', 'Max Speed'];
            let csvContent = headers.join(',') + '\n';

            filteredData.forEach(horse => {
                const row = [
                    `"${horse.name}"`,
                    horse.age || '',
                    horse.group || '',
                    horse.lastGallop || '',
                    horse.lastRace || '',
                    horse.valeur || '',
                    horse.dateOfBest5f || '',
                    formatTimeForExcel(horse.best1f),
                    formatTimeForExcel(horse.best5f),
                    formatTimeForExcel(horse.fastRecovery),
                    formatTimeForExcel(horse.recovery15min),
                    horse.maxSpeed ? horse.maxSpeed.toFixed(2) : ''
                ];
                csvContent += row.join(',') + '\n';
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'fastest_training_times.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        function showHorseDetail(horseName) {
            document.getElementById('horseDetailTitle').textContent = horseName;
            currentHorseDetailData = allHorseDetailData[horseName] || [];

            // Get and display pedigree information
            const pedigreeInfo = getHorsePedigree(horseName);
            const pedigreeTextElement = document.getElementById('horsePedigreeText');
            const ownerTextElement = document.getElementById('horseOwnerText');

            // Format: Sire - Dam, by Broodmare Sire
            if (pedigreeInfo.sire || pedigreeInfo.dam || pedigreeInfo.broodmareSire) {
                let pedigreeText = '';
                if (pedigreeInfo.sire) {
                    pedigreeText += pedigreeInfo.sire;
                }
                if (pedigreeInfo.dam) {
                    pedigreeText += (pedigreeText ? ' - ' : '') + pedigreeInfo.dam;
                }
                if (pedigreeInfo.broodmareSire) {
                    pedigreeText += ', by ' + pedigreeInfo.broodmareSire;
                }
                pedigreeTextElement.textContent = pedigreeText;
            } else {
                pedigreeTextElement.textContent = '';
            }

            // Display owner information
            if (pedigreeInfo.owner) {
                ownerTextElement.textContent = 'Propri√©taire: ' + pedigreeInfo.owner;
            } else {
                ownerTextElement.textContent = '';
            }
            
            document.getElementById('mainView').style.display = 'none';
            document.getElementById('horseDetailView').style.display = 'block';
            
            // Update back button text if not coming from gallops
            if (!navigationState.fromGallops) {
                updateBackButtonText();
            }
            
            // Reset scroll position to top and left
            window.scrollTo(0, 0);
            
            // Reset table scroll position to left
            const tableContainer = document.querySelector('.horse-detail-view .table-container');
            if (tableContainer) {
                tableContainer.scrollLeft = 0;
            }
            
            // Reset to default sort (date descending)
            currentHorseDetailSort = { column: 'date', order: 'desc' };
            document.getElementById('horseSortBy').value = 'date';
            document.getElementById('horseSortOrder').value = 'desc';
            
            // Reset age filter and workout filter
            document.getElementById('horseAgeFilter').value = '';
            document.getElementById('horseWorkoutFilter').value = 'all';
            
            // Populate age filter for this horse
            updateHorseAgeFilter(horseName);
            
            document.getElementById('horseSortBy').addEventListener('change', updateHorseDetailSort);
            document.getElementById('horseSortOrder').addEventListener('change', updateHorseDetailSort);
            document.getElementById('horseAgeFilter').addEventListener('change', updateHorseDetailSort);
            document.getElementById('horseWorkoutFilter').addEventListener('change', updateHorseDetailSort);
            document.getElementById('exportHorseCsv').addEventListener('click', exportHorseDataToCsv);

            sortHorseDetailData();
            // Weekly averages are now only generated for the modal popup, not the main view
        }

        function showMainView() {
            document.getElementById('horseDetailView').style.display = 'none';
            document.getElementById('weeklyAveragesContainer').style.display = 'none';
            document.getElementById('mainView').style.display = 'block';
            
            document.getElementById('horseFilter').value = '';
            filterData();
        }

        
        function updateHorseAgeFilter(horseName) {
            const ageFilter = document.getElementById('horseAgeFilter');
            const horseData = allHorseDetailData[horseName] || [];
            const ages = [...new Set(horseData.map(row => row.age).filter(age => age && age !== 'N/A'))].sort((a, b) => a - b);
            
            ageFilter.innerHTML = '<option value="">All Ages</option>';
            ages.forEach(age => {
                const option = document.createElement('option');
                option.value = age;
                option.textContent = age;
                ageFilter.appendChild(option);
            });
        }

        function updateHorseDetailSort() {
            const sortBy = document.getElementById('horseSortBy').value;
            const sortOrder = document.getElementById('horseSortOrder').value;
            
            currentHorseDetailSort = { column: sortBy, order: sortOrder };
            sortHorseDetailData();
        }

        function sortHorseTable(column) {
            if (currentHorseDetailSort.column === column) {
                currentHorseDetailSort.order = currentHorseDetailSort.order === 'asc' ? 'desc' : 'asc';
            } else {
                currentHorseDetailSort.column = column;
                currentHorseDetailSort.order = 'asc';
            }
            
            document.getElementById('horseSortBy').value = column;
            document.getElementById('horseSortOrder').value = currentHorseDetailSort.order;
            
            sortHorseDetailData();
        }

        function sortHorseDetailData() {
            let horseName = document.getElementById('horseDetailTitle').textContent;
            let dataToSort = allHorseDetailData[horseName] || [];
            
            // Apply age filter
            const ageFilter = document.getElementById('horseAgeFilter').value;
            if (ageFilter) {
                dataToSort = dataToSort.filter(row => row.age === ageFilter);
            }
            
            // Apply workout/race filter
            const workoutFilter = document.getElementById('horseWorkoutFilter').value;
            if (workoutFilter !== 'all') {
                dataToSort = dataToSort.filter(row => {
                    switch (workoutFilter) {
                        case 'gallops':
                            return row.isBoldRed && !row.isRaceResult;
                        case 'races':
                            return row.isRaceResult;
                        case 'gallops-races':
                            return row.isBoldRed || row.isRaceResult;
                        default:
                            return true;
                    }
                });
            }
            
            currentHorseDetailData = [...dataToSort];
            
            currentHorseDetailData.sort((a, b) => {
                let aVal = a[currentHorseDetailSort.column];
                let bVal = b[currentHorseDetailSort.column];
                
                if (currentHorseDetailSort.column === 'best200m' || currentHorseDetailSort.column === 'best800m' || currentHorseDetailSort.column === 'best1000m') {
                    aVal = aVal && isValidTime(aVal) ? timeToSeconds(aVal) : Infinity;
                    bVal = bVal && isValidTime(bVal) ? timeToSeconds(bVal) : Infinity;
                } else if (currentHorseDetailSort.column === 'age' || currentHorseDetailSort.column === 'maxSpeed' || currentHorseDetailSort.column === 'avgSpeed' || currentHorseDetailSort.column === 'maxHeartRate' || currentHorseDetailSort.column === 'recovery' || currentHorseDetailSort.column === 'recovery15min' || currentHorseDetailSort.column === 'distance' || currentHorseDetailSort.column === 'heartRateReturn' || currentHorseDetailSort.column === 'amplitude35') {
                    aVal = parseFloat(aVal) || 0;
                    bVal = parseFloat(bVal) || 0;
                } else if (currentHorseDetailSort.column === 'date') {
                    aVal = aVal ? parseEuropeanDate(aVal) : new Date(0);
                    bVal = bVal ? parseEuropeanDate(bVal) : new Date(0);
                } else {
                    aVal = aVal || '';
                    bVal = bVal || '';
                }
                
                if (currentHorseDetailSort.order === 'asc') {
                    return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                } else {
                    return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
                }
            });
            
            displayHorseDetailData();
        }

        function displayHorseDetailData() {
            const tbody = document.getElementById('horseDetailTableBody');
            
            if (currentHorseDetailData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="19" class="no-data">No training data available for this horse.</td></tr>';
                return;
            }
            
            tbody.innerHTML = currentHorseDetailData.map((row, index) => {
                const fastRecoveryColor = getFastRecoveryColor(row.recovery);
                const recovery15Color = getRecovery15Color(row.recovery15min);
                const best1000mColor = get1000mTimeColor(row.best1000m);
                
                const fastRecoveryStyle = fastRecoveryColor ? `style="background-color: ${fastRecoveryColor}; color: #000;"` : '';
                const recovery15Style = recovery15Color ? `style="background-color: ${recovery15Color}; color: #000;"` : '';
                const best1000mStyle = best1000mColor ? `style="background-color: ${best1000mColor}; color: #000;"` : '';
                
                let rowClass = '';
                let dateContent = row.date || '-';
                let horseContent = `<strong>${row.cheval || '-'}</strong>`;
                
                if (row.isRaceResult) {
                    rowClass = 'race-row';
                    
                    // Use extracted hyperlinks from Excel if available, otherwise generate them
                    if (row.dateHyperlink) {
                        dateContent = `<a href="${row.dateHyperlink}" target="_blank" style="color: inherit; text-decoration: none;">${row.date}</a>`;
                    }
                    
                    if (row.horseHyperlink) {
                        horseContent = `<a href="${row.horseHyperlink}" target="_blank" style="color: inherit; text-decoration: none; font-weight: bold;">${row.cheval || '-'}</a>`;
                    } else {
                        // Fallback: Generate tracking report URL if no hyperlink found
                        const track = extractTrackFromRecoveryText(row.recovery);
                        const raceNumber = extractRaceNumberFromText(row.recovery);
                        
                        if (track && row.date) {
                            const trackingUrl = generateTrackingReportUrl(row.date, track, raceNumber);
                            if (trackingUrl) {
                                horseContent = `<a href="${trackingUrl}" target="_blank" style="color: inherit; text-decoration: none; font-weight: bold;">${row.cheval || '-'}</a>`;
                            }
                        }
                    }
                } else if (row.isBoldRed) {
                    rowClass = 'workout-row';
                }
                
                return `
                    <tr class="${rowClass}">
                        <td>${dateContent}</td>
                        <td class="horse-name-cell">${horseContent}</td>
                        <td class="age-cell">${cleanNCValue(row.age)}</td>
                        <td>${cleanNCValue(row.distance)}</td>
                        <td class="speed-cell">${cleanNCValue(row.maxSpeed)}</td>
                        <td style="color: #000;">${cleanNCValue(row.avgSpeed)}</td>
                        <td class="time-cell">${cleanNCValue(row.best200m)}</td>
                        <td class="time-cell">${cleanNCValue(row.best800m)}</td>
                        <td class="time-cell" ${best1000mStyle}>${cleanNCValue(row.best1000m)}</td>
                        <td>${cleanNCValue(row.maxHeartRate)}</td>
                        <td class="recovery-cell" ${fastRecoveryStyle}><div class="cell-content">${cleanNCValue(row.recovery)}</div></td>
                        <td class="recovery15-cell" ${recovery15Style}>${cleanNCValue(row.recovery15min)}</td>
                        <td>${cleanNCValue(row.heartRateReturn)}</td>
                        <td>${cleanNCValue(row.amplitude35)}</td>
                        <td>${cleanNCValue(row.effort1)}</td>
                        <td>${cleanNCValue(row.effort2)}</td>
                        <td>${cleanNCValue(row.effort3)}</td>
                        <td>${cleanNCValue(row.effort4)}</td>
                        <td>${cleanNCValue(row.effort5)}</td>
                    </tr>
                `;
            }).join('');
        }
        
        function exportHorseDataToCsv() {
            if (currentHorseDetailData.length === 0) {
                alert('No data to export');
                return;
            }

            const horseName = document.getElementById('horseDetailTitle').textContent;
            
            // Create CSV header with all columns
            const headers = [
                'Date', 'Cheval', '√Çge', 'Distance du travail', 'Vitesse maximale', 'Vitesse moyenne du travail',
                'Meilleurs 200m', 'Meilleurs 800m', 'Meilleurs 1000m', 'Fr√©quence cardiaque maximale',
                'R√©cup√©ration apr√®s l\'effort', '15 min r√©cup√©ration', 'Fr√©quence cardiaque au retour',
                'Amplitude √† 35 km/h', 'Temps zone effort 1', 'Temps zone effort 2', 'Temps zone effort 3',
                'Temps zone effort 4', 'Temps zone effort 5'
            ];
            let csvContent = headers.join(',') + '\n';

            // Add data rows
            currentHorseDetailData.forEach(row => {
                const csvRow = [
                    `"${row.date || ''}"`,
                    `"${row.cheval || ''}"`,
                    row.age || '',
                    row.distance || '',
                    row.maxSpeed || '',
                    row.avgSpeed || '',
                    formatTimeForExcel(row.best200m),
                    formatTimeForExcel(row.best800m),
                    formatTimeForExcel(row.best1000m),
                    row.maxHeartRate || '',
                    formatTimeForExcel(row.recovery),
                    formatTimeForExcel(row.recovery15min),
                    row.heartRateReturn || '',
                    row.amplitude35 || '',
                    formatTimeForExcel(row.effort1),
                    formatTimeForExcel(row.effort2),
                    formatTimeForExcel(row.effort3),
                    formatTimeForExcel(row.effort4),
                    formatTimeForExcel(row.effort5)
                ];
                csvContent += csvRow.join(',') + '\n';
            });

            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `${horseName}_training_data.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
        
        // Calendar functionality
        let currentCalendarDate = new Date();
        let currentHorseForCalendar = '';

        const frenchMonths = [
            'Janvier', 'F√©vrier', 'Mars', 'Avril', 'Mai', 'Juin',
            'Juillet', 'Ao√ªt', 'Septembre', 'Octobre', 'Novembre', 'D√©cembre'
        ];

        const frenchDays = ['Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam', 'Dim'];

        function showCalendarPopup() {
            // Get current horse name from the detail title
            const title = document.getElementById('horseDetailTitle').textContent;
            currentHorseForCalendar = title;
            
            // Set calendar title
            document.getElementById('calendarTitle').textContent = `Calendrier d'Entra√Ænement - ${currentHorseForCalendar}`;
            
            // Show overlay
            const overlay = document.getElementById('calendarOverlay');
            overlay.style.display = 'flex';
            
            // Generate calendar for current month
            generateCalendar();
        }

        function hideCalendarPopup() {
            document.getElementById('calendarOverlay').style.display = 'none';
        }

        function previousMonth() {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
            generateCalendar();
        }

        function nextMonth() {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
            generateCalendar();
        }

        function generateCalendar() {
            const year = currentCalendarDate.getFullYear();
            const month = currentCalendarDate.getMonth();
            
            // Update month/year display
            document.getElementById('currentMonthYear').textContent = 
                `${frenchMonths[month]} ${year}`;
            
            // Get first day of month and number of days
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();
            
            // Get starting day of week (0=Sunday, 1=Monday, etc.)
            // Convert to European format (0=Monday, 6=Sunday)
            let startingDayOfWeek = firstDay.getDay();
            startingDayOfWeek = startingDayOfWeek === 0 ? 6 : startingDayOfWeek - 1;
            
            const calendarGrid = document.getElementById('calendarGrid');
            calendarGrid.innerHTML = '';
            
            // Add day headers
            frenchDays.forEach(day => {
                const dayHeader = document.createElement('div');
                dayHeader.className = 'calendar-day-header';
                dayHeader.textContent = day;
                calendarGrid.appendChild(dayHeader);
            });
            
            // Add empty cells for days before the month starts
            for (let i = 0; i < startingDayOfWeek; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.className = 'calendar-day other-month';
                calendarGrid.appendChild(emptyDay);
            }
            
            // Add days of the month
            for (let day = 1; day <= daysInMonth; day++) {
                const dayCell = document.createElement('div');
                dayCell.className = 'calendar-day';
                
                const dayNumber = document.createElement('div');
                dayNumber.className = 'calendar-day-number';
                dayNumber.textContent = day;
                dayCell.appendChild(dayNumber);
                
                // Add training events for this day
                addTrainingEvents(dayCell, year, month, day);
                
                calendarGrid.appendChild(dayCell);
            }
        }

        function addTrainingEvents(dayCell, year, month, day) {
            if (!currentHorseForCalendar || !currentHorseDetailData) return;
            
            const targetDate = new Date(year, month, day);
            const targetDateStr = targetDate.toLocaleDateString('fr-FR');
            
            // Find training data for this date
            const dayEvents = currentHorseDetailData.filter(row => {
                if (!row.date) return false;
                const rowDate = parseEuropeanDate(row.date);
                return rowDate && rowDate.toLocaleDateString('fr-FR') === targetDateStr;
            });
            
            // Add has-events class if there are training events
            if (dayEvents.length > 0) {
                dayCell.classList.add('has-events');
            }
            
            dayEvents.forEach(event => {
                const eventDiv = document.createElement('div');
                eventDiv.className = 'calendar-event';
                
                if (event.isRaceResult) {
                    eventDiv.classList.add('race');
                    // Show full race information with distance and race details
                    let raceInfo = '';
                    
                    // Add distance if available
                    if (event.distance) {
                        raceInfo += `${event.distance}m `;
                    }
                    
                    // Add race details from recovery field
                    if (event.recovery) {
                        const raceDetails = event.recovery.toString();
                        raceInfo += raceDetails;
                    } else {
                        raceInfo += 'Course';
                    }
                    
                    eventDiv.innerHTML = raceInfo;
                    eventDiv.style.whiteSpace = 'normal';
                    eventDiv.style.wordWrap = 'break-word';
                } else {
                    // Handle all other training days (non-race, non-gallop)
                    const best5f = event.best1000m || '';
                    const recoveryText = event.recovery || '';
                    
                    // Parse fast recovery and 15-min recovery
                    let fastRecovery = '';
                    let recovery15min = '';
                    
                    if (recoveryText.includes('/')) {
                        const parts = recoveryText.split('/');
                        fastRecovery = parts[0].trim();
                        recovery15min = parts[1] ? parts[1].trim() : '';
                    } else if (recoveryText && !isNaN(parseFloat(recoveryText))) {
                        fastRecovery = recoveryText.trim();
                    }
                    
                    // Get 15-min recovery from separate field if available
                    if (!recovery15min && event.recovery15min) {
                        recovery15min = event.recovery15min.toString();
                    }
                    
                    // Only create display if we have some data
                    if (best5f || fastRecovery || recovery15min) {
                        // Set up vertical layout for 5F time on top, recovery numbers below
                        eventDiv.style.display = 'flex';
                        eventDiv.style.flexDirection = 'column';
                        eventDiv.style.alignItems = 'center';
                        eventDiv.style.justifyContent = 'center';
                        eventDiv.style.gap = '1px';
                        // Add class for gallops and set background color
                        if (event.isBoldRed) {
                            eventDiv.classList.add('gallop');
                            // Keep the red background for gallops like before
                        } else {
                            // No fill for regular training days
                            eventDiv.style.backgroundColor = 'transparent';
                        }
                        
                        // Add 5F time on top with color coding
                        if (best5f) {
                            const timeDiv = document.createElement('div');
                            timeDiv.style.fontSize = '13px';
                            timeDiv.style.textAlign = 'center';
                            timeDiv.style.padding = '2px 4px';
                            timeDiv.style.borderRadius = '2px';
                            
                            // Apply color coding to 5F time
                            const timeColor = get1000mTimeColor(event.best1000m);
                            if (timeColor) {
                                timeDiv.style.backgroundColor = timeColor;
                                timeDiv.style.color = '#000';
                            }
                            timeDiv.textContent = best5f;
                            eventDiv.appendChild(timeDiv);
                        }
                        
                        // Add recovery values side-by-side under 5F time
                        if (fastRecovery || recovery15min) {
                            const recoveryContainer = document.createElement('div');
                            recoveryContainer.style.display = 'flex';
                            recoveryContainer.style.justifyContent = 'center';
                            recoveryContainer.style.gap = '4px';
                            recoveryContainer.style.fontSize = '12px';
                            recoveryContainer.style.fontWeight = 'bold';
                            
                            if (fastRecovery) {
                                const fastRecoveryColor = getFastRecoveryColor(fastRecovery);
                                const fastSpan = document.createElement('span');
                                fastSpan.textContent = fastRecovery;
                                fastSpan.style.padding = '2px 4px';
                                fastSpan.style.borderRadius = '2px';
                                fastSpan.style.textAlign = 'center';
                                if (fastRecoveryColor) {
                                    fastSpan.style.backgroundColor = fastRecoveryColor;
                                    fastSpan.style.color = '#000';
                                }
                                recoveryContainer.appendChild(fastSpan);
                            }
                            
                            if (recovery15min) {
                                const recovery15Color = getRecovery15Color(recovery15min);
                                const recovery15Span = document.createElement('span');
                                recovery15Span.textContent = recovery15min;
                                recovery15Span.style.padding = '2px 4px';
                                recovery15Span.style.borderRadius = '2px';
                                recovery15Span.style.textAlign = 'center';
                                if (recovery15Color) {
                                    recovery15Span.style.backgroundColor = recovery15Color;
                                    recovery15Span.style.color = '#000';
                                }
                                recoveryContainer.appendChild(recovery15Span);
                            }
                            
                            eventDiv.appendChild(recoveryContainer);
                        }
                    } else {
                        // If no training data, don't add anything to the calendar day
                        return;
                    }
                }
                
                dayCell.appendChild(eventDiv);
            });
        }

        // Close calendar when clicking outside
        document.getElementById('calendarOverlay').addEventListener('click', function(e) {
            if (e.target === this) {
                hideCalendarPopup();
            }
        });

        // PDF Export function
        async function exportCalendarToPDF() {
            try {
                // Create a clean temporary container for PDF generation
                const tempContainer = document.createElement('div');
                tempContainer.style.background = 'white';
                tempContainer.style.padding = '40px';
                tempContainer.style.width = '900px';
                tempContainer.style.position = 'absolute';
                tempContainer.style.top = '-9999px';
                tempContainer.style.left = '-9999px';
                tempContainer.style.fontFamily = 'Arial, sans-serif';
                document.body.appendChild(tempContainer);
                
                // Create clean title for PDF (just horse name and month/year)
                const monthYear = document.getElementById('currentMonthYear').textContent;
                const titleDiv = document.createElement('div');
                titleDiv.style.textAlign = 'center';
                titleDiv.style.marginBottom = '30px';
                titleDiv.style.fontSize = '24px';
                titleDiv.style.fontWeight = 'bold';
                titleDiv.style.color = '#333';
                titleDiv.textContent = `Calendrier d'Entra√Ænement - ${currentHorseForCalendar} - ${monthYear}`;
                tempContainer.appendChild(titleDiv);
                
                // Clone only the calendar grid
                const calendarGrid = document.getElementById('calendarGrid');
                const gridClone = calendarGrid.cloneNode(true);
                gridClone.style.margin = '0 auto';
                gridClone.style.maxWidth = '800px';
                
                tempContainer.appendChild(gridClone);
                
                // Generate canvas from the temporary container
                const canvas = await html2canvas(tempContainer, {
                    scale: 2,
                    useCORS: true,
                    backgroundColor: '#ffffff'
                });
                
                // Create PDF
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('landscape', 'mm', 'a4');
                
                // Calculate dimensions to fit the page with proper margins
                const pageWidth = 297; // A4 landscape width
                const pageHeight = 210; // A4 landscape height
                const margin = 20;
                const maxWidth = pageWidth - (margin * 2);
                const maxHeight = pageHeight - (margin * 2);
                
                const imgWidth = Math.min(maxWidth, (canvas.width * maxHeight) / canvas.height);
                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                
                // Center the image on the page
                const x = (pageWidth - imgWidth) / 2;
                const y = (pageHeight - imgHeight) / 2;
                
                // Add image to PDF
                const imgData = canvas.toDataURL('image/png');
                pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);
                
                // Generate filename with horse name and month/year
                const horseName = currentHorseForCalendar.replace(/[^a-zA-Z0-9]/g, '_');
                const filename = `Calendar_${horseName}_${monthYear.replace(/\s+/g, '_')}.pdf`;
                
                // Save the PDF
                pdf.save(filename);
                
                // Clean up
                document.body.removeChild(tempContainer);
                
            } catch (error) {
                console.error('Error generating PDF:', error);
                alert('Erreur lors de la g√©n√©ration du PDF. Veuillez r√©essayer.');
            }
        }

        // Gallops Comparison functionality
        let gallopsByDate = {};
        let currentGallopSort = { column: 'best5f', order: 'asc' };
        let navigationState = { fromGallops: false, gallopDate: null };


        function processGallopsByDate() {
            gallopsByDate = {};
            
            // Go through all horses and their detail data
            Object.keys(allHorseDetailData).forEach(horseName => {
                const horseDetailData = allHorseDetailData[horseName];
                if (!horseDetailData) return;
                
                horseDetailData.forEach(row => {
                    // Check if this is a gallop (using same logic as existing gallop detection)
                    if (row.isBoldRed && row.date) {
                        const dateStr = formatDateEuropean(parseEuropeanDate(row.date));
                        
                        if (!gallopsByDate[dateStr]) {
                            gallopsByDate[dateStr] = [];
                        }
                        
                        // Parse recovery values
                        let fastRecovery = '';
                        let recovery15min = '';
                        const recoveryText = row.recovery || '';
                        
                        if (recoveryText.includes('/')) {
                            const parts = recoveryText.split('/');
                            fastRecovery = parts[0].trim();
                            recovery15min = parts[1] ? parts[1].trim() : '';
                        } else if (recoveryText && !isNaN(parseFloat(recoveryText))) {
                            fastRecovery = recoveryText.trim();
                        }
                        
                        if (!recovery15min && row.recovery15min) {
                            recovery15min = row.recovery15min.toString();
                        }
                        
                        gallopsByDate[dateStr].push({
                            horse: horseName,
                            age: row.age || '',
                            distance: row.distance || '',
                            maxSpeed: row.maxSpeed || '',
                            avgSpeed: row.avgSpeed || '',
                            best200m: row.best200m || '',
                            best800m: row.best800m || '',
                            best5f: row.best1000m || '',
                            maxHeartRate: row.maxHeartRate || '',
                            fastRecovery: fastRecovery,
                            recovery15min: recovery15min,
                            heartRateReturn: row.heartRateReturn || '',
                            amplitude35: row.amplitude35 || '',
                            effort1: row.effort1 || '',
                            effort2: row.effort2 || '',
                            effort3: row.effort3 || '',
                            effort4: row.effort4 || '',
                            effort5: row.effort5 || '',
                            date: row.date
                        });
                    }
                });
            });
        }

        function showGallopsView() {
            // Process gallops data
            processGallopsByDate();
            
            // Hide main view and show gallops view
            document.getElementById('mainView').style.display = 'none';
            document.querySelector('.horse-detail-view').style.display = 'none';
            document.getElementById('weeklyAveragesContainer').style.display = 'none';
            document.getElementById('gallopView').style.display = 'block';
            
            // Populate date filter
            populateGallopDateFilter();
            
            // Show most recent gallop date by default
            const dates = Object.keys(gallopsByDate).sort((a, b) => parseEuropeanDate(b) - parseEuropeanDate(a));
            if (dates.length > 0) {
                document.getElementById('gallopDateFilter').value = dates[0];
                displayGallopsForDate(dates[0]);
            } else {
                document.getElementById('gallopTableBody').innerHTML = '<tr><td colspan="19" class="no-data">No gallops found.</td></tr>';
            }
            
        }

        function populateGallopDateFilter() {
            const select = document.getElementById('gallopDateFilter');
            select.innerHTML = '';
            
            const dates = Object.keys(gallopsByDate).sort((a, b) => parseEuropeanDate(b) - parseEuropeanDate(a));
            
            dates.forEach(date => {
                const option = document.createElement('option');
                option.value = date;
                option.textContent = parseEuropeanDate(date).toLocaleDateString('fr-FR', {
                    weekday: 'long',
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                select.appendChild(option);
            });
        }

        function changeGallopDate() {
            const selectedDate = document.getElementById('gallopDateFilter').value;
            displayGallopsForDate(selectedDate);
        }

        function displayGallopsForDate(dateStr) {
            const gallops = gallopsByDate[dateStr] || [];
            const tbody = document.getElementById('gallopTableBody');
            
            // Update title with selected date
            const formattedDate = parseEuropeanDate(dateStr).toLocaleDateString('fr-FR', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
            document.getElementById('gallopViewTitle').textContent = `Comparaison des Galops - ${formattedDate}`;
            document.getElementById('gallopViewSubtitle').textContent = `${gallops.length} cheval${gallops.length === 1 ? '' : 'x'} ont galop√© ce jour`;
            
            if (gallops.length === 0) {
                tbody.innerHTML = '<tr><td colspan="19" class="no-data">No gallops found for this date.</td></tr>';
                return;
            }
            
            // Sort gallops by current sort criteria
            gallops.sort((a, b) => {
                let aVal = a[currentGallopSort.column];
                let bVal = b[currentGallopSort.column];
                
                if (currentGallopSort.column === 'best5f' || currentGallopSort.column === 'best200m' || currentGallopSort.column === 'best800m') {
                    aVal = parseTimeToSeconds(aVal) || 999;
                    bVal = parseTimeToSeconds(bVal) || 999;
                } else if (currentGallopSort.column === 'fastRecovery' || currentGallopSort.column === 'recovery15min' || 
                         currentGallopSort.column === 'maxHeartRate' || currentGallopSort.column === 'heartRateReturn' ||
                         currentGallopSort.column === 'maxSpeed' || currentGallopSort.column === 'avgSpeed' ||
                         currentGallopSort.column === 'amplitude35' || currentGallopSort.column === 'effort1' ||
                         currentGallopSort.column === 'effort2' || currentGallopSort.column === 'effort3' ||
                         currentGallopSort.column === 'effort4' || currentGallopSort.column === 'effort5') {
                    aVal = parseFloat(aVal) || 999;
                    bVal = parseFloat(bVal) || 999;
                } else if (currentGallopSort.column === 'distance') {
                    aVal = parseFloat(aVal) || 0;
                    bVal = parseFloat(bVal) || 0;
                } else if (currentGallopSort.column === 'group') {
                    // Apply the same group sorting logic as main table
                    const getGroupSortValue = (group) => {
                        if (group === '-') return 999;
                        if (group === 'A') return 1;
                        if (group === 'B') return 2;
                        if (group === 'C') return 3;
                        if (group.includes('/')) {
                            return getGroupSortValue(group.charAt(0));
                        }
                        return 500;
                    };
                    aVal = getGroupSortValue(getHorseGroup(a.horse));
                    bVal = getGroupSortValue(getHorseGroup(b.horse));
                }
                
                if (currentGallopSort.order === 'asc') {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });
            
            tbody.innerHTML = '';
            gallops.forEach(gallop => {
                const row = document.createElement('tr');
                
                // Helper function to display values, replacing empty with '-'
                const displayValue = (value) => value && value !== 'N/C' ? value : '-';
                
                row.innerHTML = `
                    <td class="horse-name-col" style="font-weight: bold; text-align: left; cursor: pointer; width: 160px; min-width: 160px; white-space: nowrap;" onclick="goToHorseFromGallops('${gallop.horse}')">${gallop.horse}</td>
                    <td>${displayValue(gallop.age)}</td>
                    <td style="text-align: center; font-weight: bold;">${getHorseGroup(gallop.horse)}</td>
                    <td>${displayValue(gallop.distance)}</td>
                    <td>${displayValue(gallop.maxSpeed)}</td>
                    <td>${displayValue(gallop.avgSpeed)}</td>
                    <td>${displayValue(gallop.best200m)}</td>
                    <td>${displayValue(gallop.best800m)}</td>
                    <td style="background-color: ${get1000mTimeColor(gallop.best5f) || 'transparent'};">${displayValue(gallop.best5f)}</td>
                    <td>${displayValue(gallop.maxHeartRate)}</td>
                    <td style="background-color: ${getFastRecoveryColor(gallop.fastRecovery) || 'transparent'};">${displayValue(gallop.fastRecovery)}</td>
                    <td style="background-color: ${getRecovery15Color(gallop.recovery15min) || 'transparent'};">${displayValue(gallop.recovery15min)}</td>
                    <td>${displayValue(gallop.heartRateReturn)}</td>
                    <td>${displayValue(gallop.amplitude35)}</td>
                    <td>${displayValue(gallop.effort1)}</td>
                    <td>${displayValue(gallop.effort2)}</td>
                    <td>${displayValue(gallop.effort3)}</td>
                    <td>${displayValue(gallop.effort4)}</td>
                    <td>${displayValue(gallop.effort5)}</td>
                `;
                
                tbody.appendChild(row);
            });
        }

        function sortGallopTable(column) {
            if (currentGallopSort.column === column) {
                currentGallopSort.order = currentGallopSort.order === 'asc' ? 'desc' : 'asc';
            } else {
                currentGallopSort.column = column;
                currentGallopSort.order = (column === 'best5f' || column === 'fastRecovery' || column === 'recovery15min') ? 'asc' : 'desc';
            }
            
            const selectedDate = document.getElementById('gallopDateFilter').value;
            displayGallopsForDate(selectedDate);
        }

        function goToHorseFromGallops(horseName) {
            // Save current gallop state
            navigationState.fromGallops = true;
            navigationState.gallopDate = document.getElementById('gallopDateFilter').value;
            
            // Show horse detail page
            showHorseDetail(horseName);
            
            // Update back button text
            updateBackButtonText();
        }

        function updateBackButtonText() {
            const backButton = document.querySelector('.horse-detail-view .back-button');
            if (backButton) {
                if (navigationState.fromGallops) {
                    backButton.textContent = '‚Üê Back to Gallops';
                } else {
                    backButton.textContent = '‚Üê Back to Main';
                }
            }
        }

        function backToMain() {
            // Check if we came from gallops page
            if (navigationState.fromGallops) {
                // Go back to gallops page
                navigationState.fromGallops = false;
                document.querySelector('.horse-detail-view').style.display = 'none';
                document.getElementById('gallopView').style.display = 'block';
                
                // Restore the previous gallop date selection
                if (navigationState.gallopDate) {
                    document.getElementById('gallopDateFilter').value = navigationState.gallopDate;
                    displayGallopsForDate(navigationState.gallopDate);
                }
            } else {
                // Normal back to main page
                document.getElementById('gallopView').style.display = 'none';
                document.querySelector('.horse-detail-view').style.display = 'none';
                document.getElementById('mainView').style.display = 'block';
            }
        }
        
        function backToMainFromGallops() {
            document.getElementById('gallopView').style.display = 'none';
            document.querySelector('.horse-detail-view').style.display = 'none';
            document.getElementById('mainView').style.display = 'block';
            navigationState.fromGallops = false;
        }

        function exportGallopsCsv() {
            const selectedDate = document.getElementById('gallopDateFilter').value;
            const gallops = gallopsByDate[selectedDate] || [];
            
            if (gallops.length === 0) {
                alert('No gallop data to export for this date.');
                return;
            }
            
            // Get formatted date for filename
            const formattedDate = parseEuropeanDate(selectedDate).toLocaleDateString('fr-FR', { 
                year: 'numeric', 
                month: '2-digit', 
                day: '2-digit' 
            }).replace(/\//g, '-');
            
            // Create CSV headers (French)
            const headers = [
                'Cheval',
                '√Çge', 
                'Distance du travail',
                'Vitesse maximale',
                'Vitesse moyenne du travail',
                'Meilleurs 200m',
                'Meilleurs 800m', 
                'Meilleurs 1000m',
                'Fr√©quence cardiaque maximale atteinte',
                'R√©cup√©ration apr√®s l\'effort',
                '15 min r√©cup√©ration',
                'Fr√©quence cardiaque au retour',
                'Amplitude √† 35 km/h',
                'Temps zone effort 1',
                'Temps zone effort 2', 
                'Temps zone effort 3',
                'Temps zone effort 4',
                'Temps zone effort 5'
            ];
            
            // Sort gallops by current sort criteria
            const sortedGallops = [...gallops].sort((a, b) => {
                let aVal = a[currentGallopSort.column];
                let bVal = b[currentGallopSort.column];
                
                if (currentGallopSort.column === 'best5f' || currentGallopSort.column === 'best200m' || currentGallopSort.column === 'best800m') {
                    aVal = parseTimeToSeconds(aVal) || 999;
                    bVal = parseTimeToSeconds(bVal) || 999;
                } else if (currentGallopSort.column === 'fastRecovery' || currentGallopSort.column === 'recovery15min' || 
                         currentGallopSort.column === 'maxHeartRate' || currentGallopSort.column === 'heartRateReturn' ||
                         currentGallopSort.column === 'maxSpeed' || currentGallopSort.column === 'avgSpeed' ||
                         currentGallopSort.column === 'amplitude35' || currentGallopSort.column === 'effort1' ||
                         currentGallopSort.column === 'effort2' || currentGallopSort.column === 'effort3' ||
                         currentGallopSort.column === 'effort4' || currentGallopSort.column === 'effort5') {
                    aVal = parseFloat(aVal) || 999;
                    bVal = parseFloat(bVal) || 999;
                } else if (currentGallopSort.column === 'distance') {
                    aVal = parseFloat(aVal) || 0;
                    bVal = parseFloat(bVal) || 0;
                }
                
                if (currentGallopSort.order === 'asc') {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });
            
            // Create CSV content
            let csvContent = headers.join(',') + '\n';
            
            sortedGallops.forEach(gallop => {
                const displayValue = (value) => value && value !== 'N/C' ? value : '';
                
                const row = [
                    `"${gallop.horse}"`,
                    displayValue(gallop.age),
                    displayValue(gallop.distance),
                    displayValue(gallop.maxSpeed),
                    displayValue(gallop.avgSpeed),
                    formatTimeForExcel(displayValue(gallop.best200m)),
                    formatTimeForExcel(displayValue(gallop.best800m)),
                    formatTimeForExcel(displayValue(gallop.best5f)),
                    displayValue(gallop.maxHeartRate),
                    formatTimeForExcel(displayValue(gallop.fastRecovery)),
                    formatTimeForExcel(displayValue(gallop.recovery15min)),
                    displayValue(gallop.heartRateReturn),
                    displayValue(gallop.amplitude35),
                    formatTimeForExcel(displayValue(gallop.effort1)),
                    formatTimeForExcel(displayValue(gallop.effort2)),
                    formatTimeForExcel(displayValue(gallop.effort3)),
                    formatTimeForExcel(displayValue(gallop.effort4)),
                    formatTimeForExcel(displayValue(gallop.effort5))
                ];
                csvContent += row.join(',') + '\n';
            });
            
            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `Gallops_${formattedDate}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Thresholds Modal Functions
        function showThresholdsModal() {
            const overlay = document.getElementById('thresholdsOverlay');
            overlay.style.display = 'flex';
        }

        function hideThresholdsModal() {
            const overlay = document.getElementById('thresholdsOverlay');
            overlay.style.display = 'none';
        }

        // Close thresholds modal when clicking outside
        document.getElementById('thresholdsOverlay').addEventListener('click', function(e) {
            if (e.target === this) {
                hideThresholdsModal();
            }
        });

        // Recovery Tracking Functions
        let recoveryChart = null;
        let currentTimeFilter = 'fast'; // 'fast' or 'all'
        let currentDateFilter = 'all'; // 'all' or number of days
        let chartGenerationInProgress = false;

        function showRecoveryTracking() {
            const horseName = document.getElementById('horseDetailTitle').textContent;
            document.getElementById('recoveryModalTitle').textContent = `Recovery Tracking - ${horseName}`;

            // Always use the wider modal for better viewing
            const modal = document.querySelector('.recovery-modal');
            modal.classList.add('wide');

            // Show overlay
            const overlay = document.getElementById('recoveryOverlay');
            overlay.style.display = 'flex';

            // Generate chart
            generateRecoveryChart(horseName);

            // Generate weekly averages for modal
            generateWeeklyAverages(horseName);
        }

        function hideRecoveryTracking() {
            const overlay = document.getElementById('recoveryOverlay');
            overlay.style.display = 'none';

            // More thorough chart cleanup
            if (recoveryChart) {
                try {
                    recoveryChart.destroy();
                } catch (e) {
                    console.warn('Error destroying chart:', e);
                }
                recoveryChart = null;
            }

            // Clear the canvas element to prevent memory leaks
            const canvas = document.getElementById('recoveryChart');
            if (canvas && canvas.width > 0 && canvas.height > 0) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            // Reset generation flag
            chartGenerationInProgress = false;
        }

        function toggleChartData(filterType) {
            currentTimeFilter = filterType;

            // Update button states
            const fastBtn = document.getElementById('fastDaysToggle');
            const allBtn = document.getElementById('allDaysToggle');

            if (filterType === 'fast') {
                fastBtn.classList.add('active');
                allBtn.classList.remove('active');
            } else {
                allBtn.classList.add('active');
                fastBtn.classList.remove('active');
            }

            // Regenerate chart with new filter (with debouncing)
            const horseName = document.getElementById('horseDetailTitle').textContent;
            setTimeout(() => {
                generateRecoveryChart(horseName);
            }, 50);
        }

        function setDateFilter(days) {
            console.log('Setting date filter to:', days);
            currentDateFilter = days;

            // Update button states
            const buttons = ['dateAll', 'date30', 'date60', 'date90', 'date180'];
            buttons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.classList.remove('active');
            });

            const activeButtonId = days === 'all' ? 'dateAll' : `date${days}`;
            const activeBtn = document.getElementById(activeButtonId);
            if (activeBtn) {
                activeBtn.classList.add('active');
                console.log('Activated button:', activeButtonId);
            } else {
                console.log('Could not find button:', activeButtonId);
            }

            // Regenerate chart with new date filter (with debouncing)
            const horseName = document.getElementById('horseDetailTitle').textContent;
            setTimeout(() => {
                generateRecoveryChart(horseName);
            }, 50);
        }

        function generateRecoveryChart(horseName) {
            // Prevent multiple simultaneous chart generations
            if (chartGenerationInProgress) {
                console.log('Chart generation already in progress, skipping...');
                return;
            }

            chartGenerationInProgress = true;
            console.log('Generating chart with filters - Time:', currentTimeFilter, 'Date:', currentDateFilter);

            // More thorough chart cleanup
            if (recoveryChart) {
                try {
                    recoveryChart.destroy();
                } catch (e) {
                    console.warn('Error destroying previous chart:', e);
                }
                recoveryChart = null;
            }

            // Clear canvas before creating new chart
            const canvas = document.getElementById('recoveryChart');
            if (!canvas) {
                console.error('Recovery chart canvas not found');
                return;
            }

            const ctx = canvas.getContext('2d');
            if (canvas.width > 0 && canvas.height > 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            const horseData = currentHorseDetailData || [];

            if (horseData.length === 0) {
                alert('No training data available for chart generation');
                chartGenerationInProgress = false;
                return;
            }

            console.log('Raw horse data:', horseData.slice(0, 3)); // Debug first 3 entries

            // Prepare data for chart
            let chartData = horseData.map(session => {
                const date = parseEuropeanDate(session.date);
                const recoveryText = session.recovery || '';
                const recovery = parseFloat(session.recovery) || null;
                const recovery15 = parseFloat(session.recovery15min) || null;
                const best1000m = session.best1000m && isValidTime(session.best1000m) ? timeToSeconds(session.best1000m) : null;

                // Debug gallop time conversion
                if (session.isBoldRed && session.best1000m) {
                    console.log(`Gallop time debug for ${session.date}:`);
                    console.log(`  - Raw best1000m: "${session.best1000m}"`);
                    console.log(`  - isValidTime result: ${isValidTime(session.best1000m)}`);
                    console.log(`  - Converted to seconds: ${best1000m}`);
                    if (session.best1000m === "1:00.04") {
                        console.log(`  - SPECIAL DEBUG for 1:00.04`);
                        console.log(`  - timeToSeconds manual test: ${timeToSeconds("1:00.04")}`);
                    }
                }

                const dataPoint = {
                    date: date,
                    dateStr: session.date,
                    recovery: recovery,
                    recoveryText: recoveryText, // Keep original text for races
                    recovery15: recovery15,
                    time1000m: best1000m,
                    isGallop: session.isBoldRed,
                    isRace: session.isRaceResult
                };

                console.log('Processed data point:', dataPoint);
                return dataPoint;
            }).filter(item => {
                const isValid = item.date && !isNaN(item.date.getTime());
                console.log('Date validation for', item.dateStr, ':', isValid);
                return isValid;
            }).sort((a, b) => a.date - b.date);

            // Apply date filter first
            if (currentDateFilter !== 'all') {
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - currentDateFilter);
                console.log(`Before date filter: ${chartData.length} data points`);
                console.log(`Cutoff date: ${cutoffDate.toDateString()}`);
                console.log(`Sample dates from data:`, chartData.slice(0, 3).map(p => ({date: p.date, dateStr: p.dateStr})));

                chartData = chartData.filter(point => point.date >= cutoffDate);
                console.log(`After date filter: ${chartData.length} data points remaining`);

                if (chartData.length === 0) {
                    console.log('No data remaining after date filter - all dates are older than cutoff');
                }
            }

            // Create a set of race dates to exclude other data from those days
            const raceDates = new Set();
            chartData.forEach(point => {
                if (point.isRace) {
                    raceDates.add(point.dateStr);
                }
            });

            console.log('Final chart data:', chartData);

            if (chartData.length === 0) {
                alert('No valid data with dates for chart generation');
                return;
            }

            // Destroy existing chart
            if (recoveryChart) {
                recoveryChart.destroy();
            }

            // Prepare datasets
            const gallopData = [];
            const raceData = [];
            const timeData = [];
            const fastRecoveryLineData = [];
            const recovery15LineData = [];

            // Group training data into weekly averages for line chart
            const trainingGroups = {};

            chartData.forEach((point, index) => {
                const xValue = index;
                const recoveryValue = point.recovery || point.recovery15;

                // Handle races separately - they may not have recovery heart rate data
                if (point.isRace) {
                    // Debug: log all available race data
                    console.log('Race point data:', point);
                    console.log('Race recovery field:', point.recovery);
                    console.log('All race properties:', Object.keys(point));
                    console.log('FULL RACE OBJECT:', point);

                    // Check ALL fields for race-like text
                    Object.keys(point).forEach(field => {
                        if (point[field] && typeof point[field] === 'string') {
                            if (point[field].includes('-') || point[field].toLowerCase().includes('chantilly')) {
                                console.log(`*** FOUND RACE INFO in ${field}:`, point[field]);
                            }
                        }
                    });

                    // For races, use a default Y position if no recovery data
                    const raceDataPoint = {
                        x: xValue,
                        y: recoveryValue || 120, // Use recovery value or default position
                        dateStr: point.dateStr,
                        distance: point.distance || '',
                        maxSpeed: point.maxSpeed || '',
                        avgSpeed: point.avgSpeed || '',
                        best1000m: point.best1000m || '',
                        maxHeartRate: point.maxHeartRate || '',
                        raceInfo: point.recoveryText || '', // Use recoveryText which contains the race details
                        time1000m: point.time1000m
                    };

                    raceData.push(raceDataPoint);
                } else if (recoveryValue) {
                    const dataPoint = {
                        x: xValue,
                        y: recoveryValue,
                        dateStr: point.dateStr
                    };

                    if (point.isGallop) {
                        // Add full recovery info and time data for gallops
                        gallopData.push({
                            ...dataPoint,
                            recovery: point.recovery,
                            recovery15: point.recovery15,
                            time1000m: point.time1000m
                        });
                    } else {
                        // Group regular training by week
                        const date = point.date;
                        const weekStart = new Date(date);
                        weekStart.setDate(weekStart.getDate() - weekStart.getDay()); // Start of week
                        const weekKey = weekStart.toDateString();

                        if (!trainingGroups[weekKey]) {
                            trainingGroups[weekKey] = {
                                fastRecoveryValues: [],
                                recovery15Values: [],
                                indices: [],
                                dates: [],
                                weekStart: weekStart
                            };
                        }

                        // Separate fast recovery and 15min recovery
                        // Only include recovery data if the session meets the current time filter criteria
                        const maxTime = currentTimeFilter === 'fast' ? 90 : 180; // 1:30 or 3:00
                        const sessionTime = point.time1000m;
                        const includeRecovery = !sessionTime || sessionTime <= maxTime || currentTimeFilter === 'all';

                        if (point.recovery && includeRecovery) {
                            trainingGroups[weekKey].fastRecoveryValues.push(point.recovery);
                        }
                        if (point.recovery15 && includeRecovery) {
                            trainingGroups[weekKey].recovery15Values.push(point.recovery15);
                        }

                        trainingGroups[weekKey].indices.push(xValue);
                        trainingGroups[weekKey].dates.push(point.dateStr);
                    }
                }

                // Add time data if available - only for training times (not gallops, races, or days with races)
                // Filter by current time filter setting
                const maxTime = currentTimeFilter === 'fast' ? 90 : 180; // 1:30 or 3:00
                if (point.time1000m && !point.isRace && !point.isGallop && !raceDates.has(point.dateStr) && point.time1000m <= maxTime) {

                    timeData.push({
                        x: xValue,
                        y: point.time1000m,
                        dateStr: point.dateStr,
                        isGallop: point.isGallop,
                        isRace: point.isRace
                    });
                }
            });

            // Create separate recovery line data from weekly averages
            Object.values(trainingGroups).forEach(group => {
                const avgIndex = group.indices.length > 0 ?
                    group.indices.reduce((a, b) => a + b, 0) / group.indices.length : 0;

                // Fast recovery line
                if (group.fastRecoveryValues.length > 0) {
                    const avgFastRecovery = group.fastRecoveryValues.reduce((a, b) => a + b, 0) / group.fastRecoveryValues.length;
                    fastRecoveryLineData.push({
                        x: Math.round(avgIndex),
                        y: Math.round(avgFastRecovery),
                        dateStr: group.dates[0] // Use first date of the week
                    });
                }

                // 15min recovery line
                if (group.recovery15Values.length > 0) {
                    const avgRecovery15 = group.recovery15Values.reduce((a, b) => a + b, 0) / group.recovery15Values.length;
                    recovery15LineData.push({
                        x: Math.round(avgIndex),
                        y: Math.round(avgRecovery15),
                        dateStr: group.dates[0] // Use first date of the week
                    });
                }
            });

            // Sort recovery line data by x value
            fastRecoveryLineData.sort((a, b) => a.x - b.x);
            recovery15LineData.sort((a, b) => a.x - b.x);

            // Detect training gaps of 14+ days and split recovery lines
            function detectGapsAndSplitLines(lineData) {
                const splitLines = [];
                let currentSegment = [];

                for (let i = 0; i < lineData.length; i++) {
                    currentSegment.push(lineData[i]);

                    // Check if there's a gap to the next point
                    if (i < lineData.length - 1) {
                        const currentDate = parseEuropeanDate(lineData[i].dateStr);
                        const nextDate = parseEuropeanDate(lineData[i + 1].dateStr);
                        const daysDiff = (nextDate - currentDate) / (1000 * 60 * 60 * 24);

                        if (daysDiff >= 21) {
                            // End current segment and start new one
                            splitLines.push([...currentSegment]);
                            currentSegment = [];
                        }
                    }
                }

                // Add the final segment
                if (currentSegment.length > 0) {
                    splitLines.push(currentSegment);
                }

                return splitLines;
            }

            // Create single datasets with null values at gaps instead of multiple datasets
            function createDatasetWithGaps(lineData) {
                const result = [];

                for (let i = 0; i < lineData.length; i++) {
                    result.push(lineData[i]);

                    // Check if there's a gap to the next point
                    if (i < lineData.length - 1) {
                        const currentDate = parseEuropeanDate(lineData[i].dateStr);
                        const nextDate = parseEuropeanDate(lineData[i + 1].dateStr);
                        const daysDiff = (nextDate - currentDate) / (1000 * 60 * 60 * 24);

                        if (daysDiff >= 21) {
                            // Add null point to break the line
                            result.push({
                                x: lineData[i].x + 0.5,
                                y: null,
                                dateStr: null
                            });
                        }
                    }
                }

                return result;
            }

            const fastRecoveryWithGaps = createDatasetWithGaps(fastRecoveryLineData);
            const recovery15WithGaps = createDatasetWithGaps(recovery15LineData);

            // Detect gaps for red vertical lines
            function detectTrainingGaps(chartData) {
                const gaps = [];
                const trainingDates = chartData
                    .filter(point => !point.isRace && (point.recovery || point.recovery15 || point.time1000m))
                    .map(point => ({
                        date: parseEuropeanDate(point.dateStr),
                        dateStr: point.dateStr,
                        x: chartData.indexOf(point)
                    }))
                    .sort((a, b) => a.date - b.date);

                // Check gaps between training sessions
                for (let i = 0; i < trainingDates.length - 1; i++) {
                    const currentDate = trainingDates[i].date;
                    const nextDate = trainingDates[i + 1].date;
                    const daysDiff = Math.floor((nextDate - currentDate) / (1000 * 60 * 60 * 24));

                    if (daysDiff >= 21) {
                        // Find the X position between the two training sessions
                        const gapX = trainingDates[i].x + ((trainingDates[i + 1].x - trainingDates[i].x) / 2);
                        gaps.push({
                            x: gapX,
                            days: daysDiff,
                            startDate: trainingDates[i].dateStr,
                            endDate: trainingDates[i + 1].dateStr
                        });
                    }
                }

                // Check gap from last training session to today
                if (trainingDates.length > 0) {
                    const lastTraining = trainingDates[trainingDates.length - 1];
                    const today = new Date();
                    const daysSinceLastTraining = Math.floor((today - lastTraining.date) / (1000 * 60 * 60 * 24));

                    if (daysSinceLastTraining >= 21) {
                        // Position the gap line after the last training session
                        const gapX = lastTraining.x + 0.5;
                        gaps.push({
                            x: gapX,
                            days: daysSinceLastTraining,
                            startDate: lastTraining.dateStr,
                            endDate: 'Today'
                        });
                    }
                }

                return gaps;
            }

            const trainingGaps = detectTrainingGaps(chartData);


            console.log('Fast recovery line data:', fastRecoveryLineData);
            console.log('15min recovery line data:', recovery15LineData);
            console.log('Gallop data points:', gallopData);
            console.log('Race data points:', raceData);
            console.log('Time data points:', timeData);

            // Debug: Show all time values to understand the range
            const timeValues = timeData.map(d => d.y).sort((a,b) => a-b);
            console.log('Time data values (sorted):', timeValues);
            console.log('Min time:', Math.min(...timeValues));
            console.log('Max time:', Math.max(...timeValues));

            // Debug race detection
            console.log('Checking for races in chartData:');
            chartData.forEach((point, index) => {
                if (point.isRace) {
                    console.log(`Found race at index ${index}:`, point);
                }
            });

            // Check if we have any recovery data to display
            const totalDataPoints = fastRecoveryLineData.length + recovery15LineData.length + gallopData.length + raceData.length;
            if (totalDataPoints === 0) {
                alert('No recovery data available for chart generation');
                return;
            }

            console.log('Creating chart with y1 axis config:', {
                min: 50,
                max: 90,
                timeDataSample: timeData.slice(0, 5).map(d => ({x: d.x, y: d.y, date: d.dateStr}))
            });

            try {
                recoveryChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Fast Recovery Trend',
                            type: 'line',
                            data: fastRecoveryWithGaps,
                            backgroundColor: 'rgba(255, 193, 7, 0.1)',
                            borderColor: '#FFB300',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: '#FFB300',
                            fill: false,
                            yAxisID: 'y',
                            tension: 0.3,
                            spanGaps: false
                        },
                        {
                            label: '15min Recovery Trend',
                            type: 'line',
                            data: recovery15WithGaps,
                            backgroundColor: 'rgba(33, 150, 243, 0.1)',
                            borderColor: '#2196F3',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: '#2196F3',
                            fill: false,
                            yAxisID: 'y',
                            tension: 0.3,
                            spanGaps: false
                        },
                        {
                            label: 'Gallop Times',
                            data: gallopData.filter(gallop => gallop.time1000m).map(gallop => ({
                                x: gallop.x,
                                y: gallop.time1000m,
                                dateStr: gallop.dateStr,
                                isGallop: true,
                                recovery: gallop.recovery,
                                recovery15: gallop.recovery15
                            })),
                            backgroundColor: '#4CAF50',
                            borderColor: '#4CAF50',
                            borderWidth: 2,
                            pointRadius: 18,
                            pointStyle: (ctx) => {
                                // Create a custom star shape
                                const canvas = document.createElement('canvas');
                                canvas.width = 20;
                                canvas.height = 20;
                                const ctx2d = canvas.getContext('2d');

                                // Draw star
                                ctx2d.fillStyle = '#4CAF50';
                                ctx2d.beginPath();
                                const centerX = 10, centerY = 10, radius = 8;
                                for (let i = 0; i < 5; i++) {
                                    const angle = (i * 144 - 90) * Math.PI / 180;
                                    const x = centerX + radius * Math.cos(angle);
                                    const y = centerY + radius * Math.sin(angle);
                                    if (i === 0) ctx2d.moveTo(x, y);
                                    else ctx2d.lineTo(x, y);
                                }
                                ctx2d.closePath();
                                ctx2d.fill();

                                return canvas;
                            },
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Gallop Fast Recovery',
                            data: gallopData.filter(gallop => gallop.recovery),
                            backgroundColor: '#4CAF50',
                            borderColor: '#4CAF50',
                            borderWidth: 2,
                            pointRadius: 6,
                            pointStyle: 'circle',
                            yAxisID: 'y'
                        },
                        {
                            label: 'Gallop 15min Recovery',
                            data: gallopData.filter(gallop => gallop.recovery15).map(gallop => ({
                                x: gallop.x,
                                y: gallop.recovery15,
                                dateStr: gallop.dateStr,
                                isGallop: true,
                                recovery: gallop.recovery,
                                time1000m: gallop.time1000m
                            })),
                            backgroundColor: '#81C784',
                            borderColor: '#81C784',
                            borderWidth: 2,
                            pointRadius: 5,
                            pointStyle: 'circle',
                            yAxisID: 'y'
                        },
                        {
                            label: '1000m Times',
                            data: timeData,
                            backgroundColor: '#6A1B9A',
                            borderColor: '#6A1B9A',
                            borderWidth: 2,
                            pointRadius: 4,
                            yAxisID: 'y1',
                            showLine: false
                        }
                    ].concat(
                        // Add all races as a single dataset
                        raceData.length > 0 ? [{
                            label: 'Races',
                            data: raceData.map(race => ({
                                ...race,
                                y: race.time1000m || 62, // Use race time or default to 1:02 for races without time
                                backgroundColor: race.time1000m ? '#FF8C00' : '#FF6600', // Different colors but same dataset
                                borderColor: race.time1000m ? '#FF8C00' : '#FF6600'
                            })),
                            backgroundColor: '#FF8C00', // Default color for the dataset
                            borderColor: '#FF8C00',
                            borderWidth: 2,
                            pointRadius: 12,
                            pointStyle: 'triangle',
                            yAxisID: 'y1',
                            pointBorderWidth: 3
                        }] : []
                    )
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'nearest'
                    },
                    plugins: {
                        legend: {
                            display: true,
                            filter: function(legendItem, chartData) {
                                // Hide datasets with empty labels
                                return legendItem.text && typeof legendItem.text === 'string' && legendItem.text.trim() !== '';
                            }
                        },
                        title: {
                            display: false
                        },
                        tooltip: {
                            yAlign: 'top',
                            displayColors: true,
                            filter: function(tooltipItem) {
                                // Hide 1000m Times dataset when hovering over races
                                const hoveredLabel = tooltipItem.dataset.label;
                                const currentLabel = tooltipItem.dataset.label;

                                // If any dataset in the tooltip is a race, hide 1000m Times
                                const isRaceHover = tooltipItem.chart.tooltip.dataPoints?.some(point =>
                                    point.dataset.label === 'Races');

                                if (isRaceHover && currentLabel === '1000m Times') {
                                    return false; // Hide this tooltip item
                                }
                                return true; // Show this tooltip item
                            },
                            callbacks: {
                                title: function(context) {
                                    // Safety check for undefined context
                                    if (!context || !Array.isArray(context) || context.length === 0 || !context[0]) {
                                        return 'Data Point';
                                    }

                                    const contextItem = context[0];
                                    if (!contextItem.raw || !contextItem.dataset) {
                                        return 'Data Point';
                                    }

                                    const dataPoint = contextItem.raw;
                                    const datasetLabel = contextItem.dataset.label;


                                    // For races, use race name as title
                                    if (datasetLabel === 'Races') {
                                        if (dataPoint && dataPoint.raceInfo && dataPoint.raceInfo !== '') {
                                            const parts = dataPoint.raceInfo.split(' - ');
                                            if (parts.length >= 2) {
                                                return `Race: ${parts[1]}`;
                                            }
                                        }
                                        return 'Race';
                                    }

                                    return (dataPoint && dataPoint.dateStr) || `Session ${contextItem.parsed ? contextItem.parsed.x : ''}`;
                                },
                                label: function(context) {
                                    // Safety check for undefined context
                                    if (!context || !context.dataset || !context.parsed) {
                                        return 'Data point';
                                    }

                                    const datasetLabel = context.dataset.label;
                                    const value = context.parsed.y;
                                    const dataPoint = context.raw;

                                    if (datasetLabel === 'Gallop Times') {
                                        const labels = [`5F Time: ${secondsToTime(value)}`];
                                        if (dataPoint.recovery) labels.push(`Fast Recovery: ${dataPoint.recovery}`);
                                        if (dataPoint.recovery15) labels.push(`15min Recovery: ${dataPoint.recovery15}`);
                                        return labels;
                                    } else if (datasetLabel === 'Gallop Fast Recovery') {
                                        const labels = [`Fast Recovery: ${value}`];
                                        if (dataPoint.recovery15) labels.push(`15min Recovery: ${dataPoint.recovery15}`);
                                        if (dataPoint.time1000m) labels.push(`5F Time: ${secondsToTime(dataPoint.time1000m)}`);
                                        return labels;
                                    } else if (datasetLabel === 'Gallop 15min Recovery') {
                                        const labels = [`15min Recovery: ${value}`];
                                        if (dataPoint.recovery) labels.push(`Fast Recovery: ${dataPoint.recovery}`);
                                        if (dataPoint.time1000m) labels.push(`5F Time: ${secondsToTime(dataPoint.time1000m)}`);
                                        return labels;
                                    } else if (datasetLabel === '1000m Times') {
                                        return `1000m Time: ${secondsToTime(value)}`;
                                    } else if (datasetLabel === 'Races') {
                                        const labels = [`5F Time: ${secondsToTime(value)}`];
                                        if (dataPoint.raceInfo && dataPoint.raceInfo !== '') {
                                            // Parse race info like "Chantilly - Inedits - 2nd - PSF"
                                            const parts = dataPoint.raceInfo.split(' - ');
                                            if (parts.length >= 4) {
                                                labels.push(`Track: ${parts[0]}`);
                                                labels.push(`Position: ${parts[2]}`);
                                                labels.push(`Surface: ${parts[3]}`);
                                            } else {
                                                labels.push(dataPoint.raceInfo);
                                            }
                                        }
                                        if (dataPoint.distance && dataPoint.distance !== '') labels.push(`Distance: ${dataPoint.distance}m`);
                                        return labels;
                                    } else if (datasetLabel === 'Race Results') {
                                        const labels = [];
                                        if (dataPoint.raceInfo && dataPoint.raceInfo !== '') {
                                            // Parse race info like "Chantilly - Inedits - 2nd - PSF"
                                            const parts = dataPoint.raceInfo.split(' - ');
                                            if (parts.length >= 4) {
                                                labels.push(`Track: ${parts[0]}`);
                                                labels.push(`Position: ${parts[2]}`);
                                                labels.push(`Surface: ${parts[3]}`);
                                            } else {
                                                labels.push(dataPoint.raceInfo);
                                            }
                                        }
                                        if (dataPoint.distance && dataPoint.distance !== '') labels.push(`Distance: ${dataPoint.distance}m`);
                                        return labels;
                                    } else {
                                        return `${datasetLabel}: ${value}`;
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Training Session'
                            },
                            ticks: {
                                maxTicksLimit: 10,
                                callback: function(value) {
                                    const dataPoint = chartData[value];
                                    return dataPoint ? dataPoint.dateStr : '';
                                }
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Recovery Heart Rate (lower is better)'
                            },
                            reverse: false, // Low values at bottom, high at top
                            min: 60,  // Fixed minimum for consistency
                            max: 170, // Fixed maximum for consistency across all horses
                            ticks: {
                                stepSize: 10
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: '1000m Time (seconds)'
                            },
                            reverse: false, // Fast times at bottom, slow at top
                            grid: {
                                drawOnChartArea: false,
                            },
                            // Fixed range for consistency across all horses
                            min: 50,  // Start from 50 seconds (0:50)
                            max: currentTimeFilter === 'fast' ? 100 : 190, // Keep dynamic range for time filter functionality
                            ticks: {
                                stepSize: 5,
                                callback: function(value) {
                                    const minutes = Math.floor(value / 60);
                                    const seconds = Math.floor(value % 60);
                                    return minutes + ':' + seconds.toString().padStart(2, '0');
                                }
                            }
                        }
                    },
                },
                plugins: [{
                    id: 'gapIndicator',
                    beforeDraw: function(chart) {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const yScale = chart.scales.y;

                        // Draw gap lines
                        trainingGaps.forEach(gap => {
                            const xPos = chart.scales.x.getPixelForValue(gap.x);
                            const yTop = yScale.getPixelForValue(170);
                            const yBottom = yScale.getPixelForValue(60);

                            ctx.save();
                            ctx.strokeStyle = '#FF0000';
                            ctx.lineWidth = 3;
                            ctx.setLineDash([5, 5]);
                            ctx.beginPath();
                            ctx.moveTo(xPos, yTop);
                            ctx.lineTo(xPos, yBottom);
                            ctx.stroke();
                            ctx.restore();
                        });
                    },
                    afterInit: function(chart) {
                        // Add mouse move listener for gap tooltips
                        chart.canvas.addEventListener('mousemove', function(event) {
                            const rect = chart.canvas.getBoundingClientRect();
                            const x = event.clientX - rect.left;
                            const y = event.clientY - rect.top;

                            const chartArea = chart.chartArea;
                            const bottomThreshold = chartArea.bottom - (chartArea.bottom - chartArea.top) * 0.10;

                            // Only show gap tooltip when hovering in bottom 10% of chart
                            if (y > bottomThreshold && y < chartArea.bottom) {
                                let gapFound = false;
                                for (const gap of trainingGaps) {
                                    const gapXPos = chart.scales.x.getPixelForValue(gap.x);
                                    if (Math.abs(x - gapXPos) < 10) {
                                        // Show gap tooltip
                                        let tooltipEl = document.getElementById('gap-tooltip');
                                        if (!tooltipEl) {
                                            tooltipEl = document.createElement('div');
                                            tooltipEl.id = 'gap-tooltip';
                                            tooltipEl.style.position = 'absolute';
                                            tooltipEl.style.background = 'rgba(0, 0, 0, 0.9)';
                                            tooltipEl.style.color = 'white';
                                            tooltipEl.style.padding = '3px 6px';
                                            tooltipEl.style.borderRadius = '3px';
                                            tooltipEl.style.fontSize = '11px';
                                            tooltipEl.style.pointerEvents = 'none';
                                            tooltipEl.style.zIndex = '1000';
                                            document.body.appendChild(tooltipEl);
                                        }

                                        tooltipEl.innerHTML = `Training Break: ${gap.days} days`;
                                        // Position directly under the gap line at the X-axis level
                                        const gapXPos = chart.scales.x.getPixelForValue(gap.x);
                                        tooltipEl.style.left = (rect.left + gapXPos - 40) + 'px';
                                        tooltipEl.style.top = (rect.top + chartArea.bottom + 5) + 'px';
                                        tooltipEl.style.display = 'block';
                                        gapFound = true;
                                        break;
                                    }
                                }

                                if (!gapFound) {
                                    const tooltipEl = document.getElementById('gap-tooltip');
                                    if (tooltipEl) {
                                        tooltipEl.style.display = 'none';
                                    }
                                }
                            } else {
                                const tooltipEl = document.getElementById('gap-tooltip');
                                if (tooltipEl) {
                                    tooltipEl.style.display = 'none';
                                }
                            }
                        });

                        // Hide tooltip when mouse leaves canvas
                        chart.canvas.addEventListener('mouseleave', function() {
                            const tooltipEl = document.getElementById('gap-tooltip');
                            if (tooltipEl) {
                                tooltipEl.style.display = 'none';
                            }
                        });
                    }
                }]
            });
            } catch (error) {
                console.error('Error creating chart:', error);
                alert('Error generating chart. Please try closing and reopening the chart.');
                chartGenerationInProgress = false;
                hideRecoveryTracking();
                return;
            }

            // Chart generation completed successfully
            chartGenerationInProgress = false;
        }

        // Helper function to convert seconds back to time format
        function secondsToTime(seconds) {
            if (!seconds || seconds === Infinity) return '-';
            const minutes = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(2);
            return `${minutes}:${secs.padStart(5, '0')}`;
        }

        // Close recovery modal when clicking outside
        document.getElementById('recoveryOverlay').addEventListener('click', function(e) {
            if (e.target === this) {
                hideRecoveryTracking();
            }
        });

        // Weekly Performance Averages Function
        function generateWeeklyAverages(horseName) {
            const horseData = currentHorseDetailData || [];
            const modalTbody = document.getElementById('weeklyAveragesModalBody');

            if (horseData.length === 0) {
                if (modalTbody) modalTbody.innerHTML = '<tr><td colspan="5" class="no-data">No data available for weekly averages.</td></tr>';
                return;
            }

            // Filter for fast training sessions only (‚â§ 90 seconds = 1:30), excluding gallops AND races
            const fastTrainingSessions = horseData.filter(row => {
                if (row.isBoldRed || row.isRaceResult) return false; // Exclude gallops AND races
                const time5f = row.best1000m;
                if (!time5f || !isValidTime(time5f)) return false;
                return timeToSeconds(time5f) <= 90; // 1:30 or faster
            });

            // Get race results for this horse
            const raceResults = horseData.filter(row => row.isRaceResult);

            if (fastTrainingSessions.length === 0 && raceResults.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="no-data">No fast training sessions (‚â§1:30) or races found for weekly analysis.</td></tr>';
                if (modalTbody) modalTbody.innerHTML = '<tr><td colspan="5" class="no-data">No fast training sessions (‚â§1:30) or races found for weekly analysis.</td></tr>';
                return;
            }

            // Group by week
            const weeklyData = {};

            fastTrainingSessions.forEach(row => {
                const date = parseEuropeanDate(row.date);
                if (!date) return;

                // Get Monday of the week (ISO week start)
                const monday = new Date(date);
                const day = monday.getDay() || 7; // Make Sunday = 7
                monday.setDate(monday.getDate() - (day - 1));

                const weekKey = monday.toISOString().split('T')[0]; // YYYY-MM-DD format

                if (!weeklyData[weekKey]) {
                    weeklyData[weekKey] = {
                        monday: monday,
                        times: [],
                        fastRecoveries: [],
                        recovery15s: [],
                        races: []
                    };
                }

                // Add valid data points
                if (row.best1000m && isValidTime(row.best1000m)) {
                    weeklyData[weekKey].times.push(timeToSeconds(row.best1000m));
                }
                if (row.recovery && parseFloat(row.recovery)) {
                    weeklyData[weekKey].fastRecoveries.push(parseFloat(row.recovery));
                }
                if (row.recovery15min && parseFloat(row.recovery15min)) {
                    weeklyData[weekKey].recovery15s.push(parseFloat(row.recovery15min));
                }
            });

            // Add races to their respective weeks
            raceResults.forEach(row => {
                const date = parseEuropeanDate(row.date);
                if (!date) return;

                // Get Monday of the week (ISO week start)
                const monday = new Date(date);
                const day = monday.getDay() || 7; // Make Sunday = 7
                monday.setDate(monday.getDate() - (day - 1));

                const weekKey = monday.toISOString().split('T')[0]; // YYYY-MM-DD format

                if (!weeklyData[weekKey]) {
                    weeklyData[weekKey] = {
                        monday: monday,
                        times: [],
                        fastRecoveries: [],
                        recovery15s: [],
                        races: []
                    };
                }

                weeklyData[weekKey].races.push(row);
            });

            // Calculate averages and sort by date
            const weeklyAverages = Object.keys(weeklyData)
                .map(weekKey => {
                    const week = weeklyData[weekKey];
                    const sunday = new Date(week.monday);
                    sunday.setDate(sunday.getDate() + 6);

                    return {
                        weekKey,
                        monday: week.monday,
                        sunday: sunday,
                        sessionCount: Math.max(week.times.length, week.fastRecoveries.length, week.recovery15s.length),
                        avgTime: week.times.length > 0 ? week.times.reduce((a,b) => a+b, 0) / week.times.length : null,
                        avgFastRecovery: week.fastRecoveries.length > 0 ? week.fastRecoveries.reduce((a,b) => a+b, 0) / week.fastRecoveries.length : null,
                        avgRecovery15: week.recovery15s.length > 0 ? week.recovery15s.reduce((a,b) => a+b, 0) / week.recovery15s.length : null,
                        races: week.races
                    };
                })
                .sort((a, b) => b.monday - a.monday); // Most recent first

            // Color coding functions - using background colors to match main table
            function getTimeColor(seconds) {
                if (!seconds) return '';
                if (seconds <= 63) return 'style="background-color: #d1ecf1; color: #000;"'; // Blue - excellent
                if (seconds <= 71) return 'style="background-color: #d4edda; color: #000;"'; // Green - good
                if (seconds <= 110) return 'style="background-color: #f9f7e3; color: #000;"'; // Light yellow - fair
                return 'style="background-color: #fdeaea; color: #000;"'; // Light red - poor
            }

            function getRecoveryColor(value) {
                if (!value) return '';
                const numValue = parseFloat(value);
                if (isNaN(numValue)) return '';

                // Match main table thresholds for fast recovery
                if (numValue >= 140) return 'style="background-color: #fdeaea; color: #000;"'; // Red
                if (numValue >= 125) return 'style="background-color: #fff3cd; color: #000;"'; // Yellow
                if (numValue >= 119) return 'style="background-color: #f9f7e3; color: #000;"'; // Light yellow
                if (numValue >= 101) return 'style="background-color: #d4edda; color: #000;"'; // Green
                return 'style="background-color: #d1ecf1; color: #000;"'; // Blue
            }

            function getRecovery15Color(value) {
                if (!value) return '';
                const numValue = parseFloat(value);
                if (isNaN(numValue)) return '';

                // Match main table thresholds for 15min recovery
                if (numValue >= 116) return 'style="background-color: #fdeaea; color: #000;"'; // Red
                if (numValue >= 102) return 'style="background-color: #fff3cd; color: #000;"'; // Yellow
                if (numValue >= 81) return 'style="background-color: #d4edda; color: #000;"'; // Green
                return 'style="background-color: #d1ecf1; color: #000;"'; // Blue
            }

            // Generate table rows
            let html = '';
            weeklyAverages.forEach((week, index) => {
                const prevWeek = weeklyAverages[index + 1];

                const weekRange = `${week.monday.toLocaleDateString('fr-FR', {month: 'short', day: 'numeric'})} - ${week.sunday.toLocaleDateString('fr-FR', {month: 'short', day: 'numeric'})}`;

                // Add race result rows for this week FIRST
                week.races.forEach(race => {
                    const raceDate = parseEuropeanDate(race.date);
                    const formattedDate = raceDate ? raceDate.toLocaleDateString('fr-FR', {month: 'short', day: 'numeric'}) : race.date;

                    // Extract race information from available fields
                    const raceTime = race.best1000m && isValidTime(race.best1000m) ? race.best1000m : null;
                    const distance = race.distance || '';
                    const valeur = race.valeur ? parseFloat(race.valeur) :
                                  race.maxHeartRate ? parseFloat(race.maxHeartRate) : null;

                    // Debug valeur
                    console.log('Race valeur debug:');
                    console.log('  race.valeur raw:', race.valeur);
                    console.log('  valeur parsed:', valeur);
                    console.log('  All race fields:', Object.keys(race));
                    Object.keys(race).forEach(key => {
                        if (key.toLowerCase().includes('valeur') || key.toLowerCase().includes('freq') || key.toLowerCase().includes('cardiaque') ||
                            key.toLowerCase().includes('heart') || key.toLowerCase().includes('max') ||
                            (typeof race[key] === 'string' && race[key].match(/^[0-9]{1,2}(\.[0-9])?$/) && parseFloat(race[key]) < 65)) {
                            console.log(`  ${key}: ${race[key]}`);
                        }
                    });

                    // The race info is in the recovery field: "Chantilly - Inedits - 2nd - PSF"
                    const raceInfoString = race.recovery || '';

                    let raceDetails = '';

                    // If we found the combined race info string, parse it
                    if (raceInfoString) {
                        const parts = raceInfoString.split(' - ');
                        if (parts.length >= 4) {
                            const track = parts[0]?.trim() || '';
                            const raceName = parts[1]?.trim() || '';
                            const position = parts[2]?.trim() || '';
                            const surface = parts[3]?.trim() || '';

                            let raceInfo = [];
                            if (raceName) raceInfo.push(raceName);
                            if (raceTime) raceInfo.push(`5F: ${raceTime}`);
                            if (track) raceInfo.push(track);
                            if (position) raceInfo.push(position);
                            if (surface) raceInfo.push(surface);
                            if (distance) raceInfo.push(`${distance}m`);
                            if (valeur) raceInfo.push(`<strong>Valeur: ${valeur}</strong>`);

                            raceDetails = raceInfo.join(' | ');
                        }
                    }

                    // Fallback if parsing failed
                    if (!raceDetails) {
                        let raceInfo = [];
                        if (raceTime) raceInfo.push(`5F: ${raceTime}`);
                        if (distance) raceInfo.push(`${distance}m`);
                        if (valeur) raceInfo.push(`<strong>Valeur: ${valeur}</strong>`);
                        raceDetails = raceInfo.join(' | ') || 'Race';
                    }

                    // Determine race emoji based on position
                    let raceEmoji = 'üèÅ'; // Default flag
                    if (raceInfoString) {
                        const parts = raceInfoString.split(' - ');
                        if (parts.length >= 3) {
                            const position = parts[2]?.trim().toLowerCase();
                            if (position === '1st' || position === '1er' || position === '1') {
                                raceEmoji = 'ü•á'; // Gold medal
                            } else if (position === '2nd' || position === '2e' || position === '2') {
                                raceEmoji = 'ü•à'; // Silver medal
                            } else if (position === '3rd' || position === '3e' || position === '3') {
                                raceEmoji = 'ü•â'; // Bronze medal
                            }
                            // 4th or worse keeps the flag emoji üèÅ
                        }
                    }

                    html += `<tr style="background-color: #e6f3ff; border-left: 4px solid #2196F3;">
                        <td style="font-weight: bold;">${formattedDate}</td>
                        <td colspan="4" style="padding: 8px; font-size: 13px; white-space: nowrap;">
                            ${raceEmoji} ${raceDetails}
                        </td>
                    </tr>`;
                });

                // Then add weekly average row if there are training sessions
                if (week.sessionCount > 0) {
                    html += `<tr>
                        <td style="font-weight: bold;">${weekRange}</td>
                        <td style="text-align: center;">${week.sessionCount}</td>
                        <td ${getTimeColor(week.avgTime)} style="text-align: center;">
                            ${week.avgTime ? secondsToTime(week.avgTime) : '-'}
                        </td>
                        <td ${getRecoveryColor(week.avgFastRecovery)} style="text-align: center;">
                            ${week.avgFastRecovery ? Math.round(week.avgFastRecovery) : '-'}
                        </td>
                        <td ${getRecovery15Color(week.avgRecovery15)} style="text-align: center;">
                            ${week.avgRecovery15 ? Math.round(week.avgRecovery15) : '-'}
                        </td>
                    </tr>`;
                }
            });

            if (modalTbody) modalTbody.innerHTML = html;
        }


    </script>
    
    <div class="lost-numbers">4 8 15 16 23 42</div>
</body>
</html>